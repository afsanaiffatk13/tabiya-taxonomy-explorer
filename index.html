<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Tabiya Taxonomy Explorer</title>
    
    <!-- Papa Parse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <!-- Performance optimization modules -->
    <script src="virtual-scroller.js"></script>
    <script src="performance-manager.js"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
    @charset "UTF-8";

        :root {
            /* Primary Brand Colors - EXACT Tabiya values */
            --tabiya-green: #00FF91;
            --tabiya-dark-green: #247066;
            --tabiya-soft-green: #E8F5E8;
            --tabiya-light-green: #D7FFEF;
            --oxford-blue: #002147;
            --tabiya-grey: #F8F5F0;
            
            /* Supporting Colors - EXACT Tabiya values */
            --white: #FFFFFF;
            --text-primary: #002147;
            --text-secondary: #247066;
            --text-muted: #6B7280;
            --border-light: #E5E7EB;
            --bg-light: #F8F5F0;
            --bg-white: #FFFFFF;
            --warning-color: #F6E05E;
            --success-color: #68D391;
            --error-color: #FC8181;
            
            /* Typography */
            --font-family-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-family-mono: 'DM Mono', 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            
            /* Font Weights */
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --font-weight-bold: 700;
            
            /* Spacing Scale */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            --space-2xl: 48px;
            
            /* Border Radius */
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-pill: 50px;
        }

        /* ========== FONT CORRUPTION FIXES ========== */
        /* Ensure proper text rendering and prevent corruption */
        * {
            /* Prevent text transform issues that cause corruption */
            text-transform: none !important;
            
            /* Reset font properties that can cause corruption */
            font-variant: normal !important;
            font-feature-settings: normal !important;
            font-kerning: auto !important;
            
            /* Ensure proper text direction */
            unicode-bidi: normal !important;
            direction: ltr !important;
            writing-mode: horizontal-tb !important;
            
            /* Optimize text rendering */
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Specific fixes for tree elements */
        .tree-item,
        .tree-node,
        .tree-label,
        .tree-code,
        .occupation-item,
        .skill-item,
        .tree-container,
        .left-panel,
        .taxonomy-tree {
            /* Force consistent font family */
            font-family: var(--font-family-sans) !important;
            
            /* Prevent any text transformations */
            text-transform: none !important;
            text-decoration: none !important;
            text-indent: 0 !important;
            
            /* Reset problematic font properties */
            font-variant: normal !important;
            font-feature-settings: normal !important;
            font-stretch: normal !important;
            font-synthesis: weight style !important;
            
            /* Ensure proper encoding */
            unicode-bidi: normal !important;
            direction: ltr !important;
            writing-mode: horizontal-tb !important;
            
            /* Character spacing fixes */
            letter-spacing: normal !important;
            word-spacing: normal !important;
            white-space: normal !important;
        }

        /* Input field fixes */
        .search-box,
        input[type="text"],
        textarea {
            /* Prevent input corruption */
            font-family: var(--font-family-sans) !important;
            text-transform: none !important;
            unicode-bidi: normal !important;
            direction: ltr !important;
        }

        /* Detail panel text fixes */
        .detail-title,
        .detail-description,
        .breadcrumb-nav,
        .alt-labels-list {
            font-family: var(--font-family-sans) !important;
            text-transform: none !important;
            unicode-bidi: normal !important;
            direction: ltr !important;
        }

        /* Button and navigation fixes */
        .nav-tab,
        .sub-nav-tab,
        .btn-header,
        .btn-control,
        .export-button,
        .lang-btn,
        .loc-btn {
            font-family: var(--font-family-sans) !important;
            text-transform: none !important;
            unicode-bidi: normal !important;
            direction: ltr !important;
        }

        /* Ensure all text content uses proper encoding */
        body,
        html {
            /* Force UTF-8 character handling */
            font-family: var(--font-family-sans);
            
            /* Prevent text corruption */
            text-transform: none !important;
            unicode-bidi: normal;
            direction: ltr;
            
            /* Optimal text rendering */
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Fix for any pseudo-elements that might cause corruption */
        *::before,
        *::after {
            font-family: inherit !important;
            text-transform: none !important;
            unicode-bidi: normal !important;
            direction: ltr !important;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--bg-light) 0%, #EDF2F7 100%);
            font-family: var(--font-family-sans);
            font-weight: var(--font-weight-normal);
            line-height: 1.6;
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0;
        }

        /* Enhanced Header with subtle animation */
        .header {
            background: var(--oxford-blue);
            color: white;
            padding: var(--space-xl);
            box-shadow: 0 4px 20px rgba(0, 33, 71, 0.1);
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1400px;
            margin: 0 auto;
            animation: slideInFromTop 0.6s ease-out;
        }

        @keyframes slideInFromTop {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .logo-section {
            display: flex;
            align-items: center;
        }

        .logo-icon {
            width: 56px;
            height: 56px;
            background: var(--tabiya-green);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 20px;
            font-size: 28px;
            color: var(--oxford-blue);
            box-shadow: 0 4px 12px rgba(0, 255, 145, 0.3);
            font-weight: var(--font-weight-semibold);
        }

        .header h1 {
            font-size: 28px;
            font-weight: var(--font-weight-bold);
            margin: 0 0 6px 0;
            letter-spacing: -0.02em;
        }

        .header p {
            opacity: 0.85;
            margin: 0;
            font-size: 16px;
            font-weight: var(--font-weight-normal);
        }

        .header-actions {
            display: flex;
            gap: 16px;
        }

        .btn-header {
            background: var(--tabiya-green);
            color: var(--oxford-blue);
            padding: 14px 24px;
            border-radius: var(--radius-lg);
            text-decoration: none;
            font-size: 15px;
            font-weight: var(--font-weight-semibold);
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 255, 145, 0.2);
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-header:hover {
            background: #00E682;
            color: var(--oxford-blue);
            text-decoration: none;
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0, 255, 145, 0.3);
        }

        /* Language Switcher */
        .language-switcher {
            display: flex;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-lg);
            padding: 4px;
        }

        .lang-btn {
            background: transparent;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            font-weight: var(--font-weight-semibold);
            transition: all 0.2s ease;
            font-family: var(--font-family-sans);
        }

        .lang-btn.active {
            background: var(--tabiya-green);
            color: var(--oxford-blue);
        }

        .lang-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Localization Selector */
        .localization-selector {
            display: flex;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-lg);
            padding: 4px;
            margin-left: 12px;
        }

        .loc-btn {
            background: var(--tabiya-grey);
            color: var(--text-primary);
            border: none;
            padding: 8px 12px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 13px;
            font-weight: var(--font-weight-semibold);
            transition: all 0.2s ease;
            font-family: var(--font-family-sans);
        }

        .loc-btn.active {
            background: var(--tabiya-green);
            color: var(--oxford-blue);
        }

        .loc-btn:hover:not(.active) {
            background: var(--tabiya-soft-green);
        }

        /* Localization highlighting */
        .localized-badge {
            font-size: 10px;
            padding: 2px 6px;
            background: #ff6b35;
            color: white;
            border-radius: 3px;
            font-weight: bold;
            margin-left: 6px;
        }

        .localized-addition {
            color: #ff6b35;
            font-weight: 600;
        }

        .localized-alt-labels {
            color: #ff6b35;
            font-style: italic;
            font-weight: 500;
        }

        .tree-node.localized-item {
            border-left: 3px solid #ff6b35;
        }

        /* Enhanced Main Content */
        .main-content {
            background: var(--bg-white);
            margin: 32px;
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid var(--border-light);
            box-shadow: 0 8px 32px rgba(26, 43, 61, 0.08);
        }

        /* Enhanced Navigation */
        .top-nav {
            background: var(--tabiya-grey);
            padding: var(--space-xl);
            border-bottom: 1px solid var(--border-light);
            position: relative;
        }

        .nav-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            margin-bottom: 20px;
        }

        .nav-tabs {
            display: flex;
            gap: 4px;
            margin: 0;
            padding: 0;
            list-style: none;
            position: relative;
        }

        .nav-tab {
            background: var(--white);
            color: var(--text-secondary);
            padding: 16px 28px 20px 28px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: var(--font-weight-semibold);
            font-size: 15px;
            position: relative;
            border: 2px solid var(--border-light);
            display: flex;
            align-items: center;
            gap: 8px;
            /* Clean rounded rectangle tabs */
            border-radius: var(--radius-lg);
            margin-right: -8px;
            z-index: 1;
            border-radius: var(--radius-md) var(--radius-md) 0 0;
        }

        .nav-tab.active {
            background: var(--oxford-blue);
            color: white;
            border-color: var(--oxford-blue);
            z-index: 3;
            transform: translateY(-2px);
        }

        .nav-tab:hover:not(.active) {
            background: var(--tabiya-light-green);
            color: var(--oxford-blue);
            border-color: var(--tabiya-green);
            z-index: 2;
            transform: translateY(-1px);
        }

        .export-button {
            background: var(--oxford-blue);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: var(--radius-lg);
            cursor: pointer;
            font-size: 14px;
            font-weight: var(--font-weight-semibold);
            font-family: var(--font-family-sans);
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .export-button:hover {
            background: var(--tabiya-dark-green);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 33, 71, 0.3);
        }

        .sub-nav-tabs {
            display: none;
            gap: 10px;
            margin: 0;
            padding: 16px 0;
            list-style: none;
            background: transparent;
            border: none;
            margin-top: 10px;
        }

        .sub-nav-tabs.active {
            display: flex;
        }

        .sub-nav-tab {
            background: var(--white);
            color: var(--text-secondary);
            padding: 16px 28px 20px 28px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: var(--font-weight-semibold);
            font-size: 15px;
            position: relative;
            border: 2px solid var(--border-light);
            display: flex;
            align-items: center;
            gap: 8px;
            /* Clean rounded rectangle tabs */
            border-radius: var(--radius-lg);
            margin-right: -8px;
            z-index: 1;
            border-radius: var(--radius-md) var(--radius-md) 0 0;
        }

        .sub-nav-tab.active {
            background: var(--oxford-blue);
            color: white;
            border-color: var(--oxford-blue);
            z-index: 3;
            transform: translateY(-2px);
        }

        .sub-nav-tab:hover:not(.active) {
            background: var(--tabiya-light-green);
            color: var(--oxford-blue);
            border-color: var(--tabiya-green);
            z-index: 2;
            transform: translateY(-1px);
        }

        .tab-badge {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            margin-left: 8px;
            font-weight: var(--font-weight-bold);
            background: var(--oxford-blue);
            color: white;
            font-family: var(--font-family-sans);
        }

        .nav-tab.active .tab-badge {
            background: var(--tabiya-green);
            color: var(--oxford-blue);
        }

        .sub-nav-tab.active .tab-badge {
            background: var(--oxford-blue);
            color: white;
        }

        /* Explorer Layout */
        .explorer-layout {
            display: flex;
            min-height: calc(100vh - 240px);
        }

        .sidebar {
            width: 420px; /* Increased from 400px */
            min-width: 420px;
            max-width: 420px;
            background: var(--bg-light);
            padding: 32px 24px; /* Reduced horizontal padding */
            overflow-y: auto;
            overflow-x: hidden; /* Prevent horizontal scroll */
            border-right: 1px solid var(--border-light);
        }

        /* Ensure tree content doesn't overflow */
        .tree-container {
            width: 100%;
            overflow-x: hidden;
        }



        .main-panel {
            flex: 1;
            padding: 32px;
            background: var(--bg-white);
            overflow-y: auto;
        }

        /* Enhanced Search */
        .search-section {
            margin-bottom: var(--space-xl);
        }

        .search-box {
            width: 100%;
            padding: 18px 24px;
            background: var(--white);
            border: 2px solid var(--border-light);
            border-radius: var(--radius-lg);
            font-size: 16px;
            font-family: var(--font-family-sans);
            font-weight: var(--font-weight-normal);
            color: var(--text-primary);
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }

        .search-box:focus {
            outline: none;
            border-color: var(--tabiya-green);
            box-shadow: 0 0 0 3px rgba(0, 255, 145, 0.15);
            background: var(--white);
        }

        .search-box::placeholder {
            color: var(--text-muted);
            font-weight: var(--font-weight-normal);
        }

        .search-stats {
            margin-top: 16px;
            font-size: 14px;
            color: var(--text-muted);
            font-weight: var(--font-weight-medium);
            font-family: var(--font-family-sans);
        }

        /* Enhanced Controls */
        .controls-section {
            display: none; /* Hide the old controls section since export moved to top */
        }

        .btn-control {
            background: var(--oxford-blue);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(26, 43, 61, 0.2);
        }

        .btn-control:hover {
            background: var(--tabiya-dark-green);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(26, 43, 61, 0.3);
        }

        /* Tree Structure with conditional spacing for different item types */
        .tree-item {
            margin: 0;
        }

        .tree-node {
            display: flex;
            align-items: center;
            padding: 14px 20px;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 15px;
            user-select: none;
            margin: 3px 0;
            background: var(--white);
            border: 1px solid transparent;
            position: relative;
            min-height: 44px;
            width: 100%;
            box-sizing: border-box;
        }

        .tree-node {
            font-family: var(--font-family-sans);
            text-transform: none;
        }

        .tree-node .tree-label {
            font-family: inherit;
            text-transform: none;
            text-decoration: none;
        }

        .tree-node:hover {
            background: var(--tabiya-soft-green);
            border-color: var(--tabiya-green);
            transform: translateX(2px);
        }

        .tree-node.selected {
            background: var(--oxford-blue);
            color: white;
            border-color: var(--oxford-blue);
        }

        .tree-node.has-children {
            cursor: pointer; /* Expandable items show pointer cursor */
        }

        .tree-node:not(.has-children) {
            cursor: pointer; /* Non-expandable items also show pointer for selection */
        }

        /* Enhanced toggle area - now just an indicator, not separately clickable */
        .tree-toggle {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 12px;
            color: var(--text-muted);
            flex-shrink: 0;
            pointer-events: none;
        }

        .tree-node.has-children .tree-toggle {
            color: var(--tabiya-dark-green);
        }

        .tree-node.selected .tree-toggle {
            color: var(--tabiya-green);
        }

        /* Remove toggle space for non-expandable individual skills */
        .tree-node.skill-item .tree-toggle {
            width: 0;
            margin-right: 0;
            overflow: hidden;
        }

        /* Conditional code spacing */
        .tree-code {
            font-family: var(--font-family-sans);
            font-weight: var(--font-weight-semibold);
            margin-right: 12px;
            color: var(--tabiya-dark-green);
            font-size: 13px;
            background: rgba(36, 112, 102, 0.1);
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            min-width: 60px;
            max-width: 80px;
            text-align: center;
            flex-shrink: 0;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        .tree-node.selected .tree-code {
            background: var(--tabiya-green);
            color: var(--oxford-blue);
        }
        
        /* Individual skills don't show codes, so no code margin */
        .tree-node.skill-item .tree-code {
            display: none;
        }

        /* Adjust label positioning for skill items */
        .tree-node.skill-item .tree-label {
            padding-left: 8px;
            font-style: normal;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: var(--font-weight-normal);
        }

        .tree-node.skill-item {
            background: var(--white) !important;
            border: 1px solid var(--border-light) !important;
            color: var(--text-primary) !important;
        }

        .tree-node.skill-item:hover {
            background: var(--tabiya-soft-green) !important;
            border-color: var(--tabiya-green) !important;
            color: var(--text-primary) !important;
        }

        .tree-node.skill-item.selected {
            background: var(--oxford-blue) !important;
            color: white !important;
            border-color: var(--oxford-blue) !important;
        }

        .tree-node.skill-item .tree-label {
            color: inherit !important;
            font-weight: var(--font-weight-normal) !important;
        }

        .tree-node.skill-item:hover .tree-label {
            color: var(--text-primary) !important;
        }

        .tree-node.skill-item.selected .tree-label {
            color: white !important;
        }

        .tree-label {
            flex: 1;
            font-weight: 500;
            line-height: 1.4;
            word-wrap: break-word;
            overflow-wrap: break-word;
            
            /* CRITICAL: Prevent text corruption */
            text-transform: none !important;
            font-variant: normal !important;
            letter-spacing: normal !important;
            unicode-bidi: normal !important;
            direction: ltr !important;
            writing-mode: horizontal-tb !important;
            
            /* Ensure proper font rendering */
            font-family: var(--font-family-sans) !important;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Enhanced children container with better spacing */
        .tree-children {
            margin-left: 16px;
            padding-left: 16px;
            border-left: 1px solid var(--border-light);
            margin-top: 4px;
        }

        .tree-children.collapsed {
            display: none;
        }

        /* Special styling for expandable individual skills */
        .tree-node.skill-item.expandable {
            font-weight: 500;
            color: var(--text-primary);
        }

        .tree-node.skill-item.expandable .tree-toggle {
            width: 20px;
            margin-right: 8px;
        }

        .tree-node.skill-item.expandable .tree-label {
            font-style: normal;
            color: var(--text-primary);
        }

        /* Enhanced Detail Panel */
        .detail-header {
            padding-bottom: 24px;
            margin-bottom: 32px;
            border-bottom: 1px solid var(--border-light);
        }

        .detail-title {
            font-size: 32px;
            color: var(--oxford-blue);
            margin-bottom: 12px;
            font-weight: 700;
            letter-spacing: -0.025em;
            line-height: 1.2;
        }

        .detail-code {
            font-family: 'DM Mono', monospace;
            font-size: 32px;
            color: var(--tabiya-dark-green);
            font-weight: 600;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .detail-description {
            color: var(--oxford-blue);
            line-height: 1.7;
            font-size: 16px;
            margin-bottom: 24px;
        }

        /* Breadcrumb Navigation */
        .breadcrumb-nav {
            background: transparent;
            padding: 16px 0;
            margin-bottom: 24px;
            border: none;
        }

        .breadcrumb-nav a {
            color: var(--oxford-blue);
            text-decoration: none;
            font-weight: var(--font-weight-semibold);
            font-size: 16px;
            transition: all 0.2s ease;
            padding: 4px 8px;
            border-radius: var(--radius-sm);
        }

        .breadcrumb-nav a:hover {
            background: var(--tabiya-light-green);
            color: var(--oxford-blue);
        }

        .breadcrumb-nav span {
            font-size: 16px;
        }

        /* Alternative Labels Section */
        .alt-labels-section {
            background: transparent;
            padding: 24px 0;
            margin: 32px 0;
            border: none;
        }

        .alt-labels-list {
            color: var(--text-secondary);
            line-height: 1.6;
            font-size: 15px;
            font-style: italic;
        }

        /* Skills Section - Enhanced styling */
        .skills-section {
            background: var(--tabiya-grey);
            padding: 24px;
            border-radius: 12px;
            margin: 32px 0;
        }

        .skills-section h4 {
            color: var(--oxford-blue);
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .skills-inline {
            line-height: 1.8;
        }

        .skill-link {
            color: var(--oxford-blue);
            text-decoration: none;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .skill-link:hover {
            background: var(--tabiya-green);
            color: var(--oxford-blue);
            text-decoration: none;
        }

        /* Related Items */
        .related-section {
            margin-top: 32px;
        }

        .related-section h4 {
            color: var(--oxford-blue);
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: 700;
        }

        .related-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 16px;
        }

        .related-item {
            background: var(--tabiya-grey);
            padding: 20px;
            border-radius: var(--radius-lg);
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid var(--border-light);
        }

        .related-item:hover {
            background: var(--tabiya-soft-green);
            transform: translateY(-2px);
            border-color: var(--tabiya-green);
            box-shadow: 0 4px 12px rgba(0, 255, 145, 0.1);
        }

        .related-item-code {
            font-family: 'DM Mono', monospace;
            font-weight: 600;
            color: var(--tabiya-dark-green);
            font-size: 13px;
            margin-bottom: 8px;
        }

        .related-item-label {
            font-weight: 600;
            color: var(--oxford-blue);
            margin-bottom: 8px;
            font-size: 16px;
            line-height: 1.4;
        }

        .related-item-desc {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 80px 32px;
            color: var(--text-muted);
        }

        .empty-state i {
            font-size: 48px;
            color: var(--oxford-blue);
            margin-bottom: 24px;
        }

        .empty-state h3 {
            color: var(--oxford-blue);
            margin-bottom: 12px;
            font-size: 24px;
            font-weight: 600;
        }

        .empty-state p {
            font-size: 16px;
            max-width: 400px;
            margin: 0 auto;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 60px;
            color: var(--text-muted);
        }

        .loading i {
            animation: spin 1s linear infinite;
            font-size: 32px;
            color: var(--oxford-blue);
            margin-bottom: 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Search highlighting */
        mark {
            background: var(--tabiya-green);
            color: var(--oxford-blue);
            padding: 2px 4px;
            border-radius: 4px;
            font-weight: 600;
        }

        /* Debug indicator */
        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--oxford-blue);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'DM Mono', monospace;
            z-index: 1000;
        }

        /* Enhanced Responsive Design */
        @media (max-width: 1024px) {
            .sidebar {
                width: 380px;
                min-width: 380px;
                max-width: 380px;
                padding: 24px 20px;
            }
            
            .tree-code {
                min-width: 50px;
                max-width: 70px;
                font-size: 12px;
            }
        }
        
        @media (max-width: 768px) {
            .header {
                padding: 20px 24px;
            }
            
            .header-content {
                flex-direction: column;
                gap: 16px;
                text-align: center;
            }
            
            .header-actions {
                order: -1;
            }
            
            .main-content {
                margin: 8px;
            }
            
            .explorer-layout {
                flex-direction: column;
                min-height: auto;
            }
            
            .sidebar {
                width: 100%;
                padding: 20px;
            }
            
            .main-panel {
                padding: 20px;
            }
            
            .nav-tabs, .sub-nav-tabs {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .nav-tab, .sub-nav-tab {
                padding: 10px 16px;
                font-size: 14px;
            }
            
            .controls-section {
                flex-direction: column;
                gap: 16px;
                align-items: stretch;
            }
            
            .detail-title {
                font-size: 24px;
            }
            
            .related-items {
                grid-template-columns: 1fr;
            }
        }
        
        
        .tree-node {
            display: flex;
            align-items: center;
            padding: 14px 20px;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 15px;
            user-select: none;
            margin: 3px 0;
            background: var(--white);
            border: 1px solid transparent;
        }

        /* Enhanced active/click feedback */
        .tree-node:active {
            transform: scale(0.98) translateX(2px);
            background: var(--tabiya-light-green);
        }

        .tree-node.has-children:active .tree-toggle i {
            transform: scale(1.1);
        }

        .logo-image {
            width: 56px !important;
            height: 56px !important;
            max-width: 56px !important;
            max-height: 56px !important;
            min-width: 56px !important;
            min-height: 56px !important;
            margin-right: 20px;
            border-radius: var(--radius-lg);
            object-fit: contain;
            display: block;
            flex-shrink: 0;
        }

        @media (max-width: 768px) {
            .logo-image {
                width: 40px !important;
                height: 40px !important;
                max-width: 40px !important;
                max-height: 40px !important;
                min-width: 40px !important;
                min-height: 40px !important;
            }
        }
        

        /* Updated localization badge styling */
        .localized-badge {
            font-size: 9px;
            padding: 2px 4px;
            background: var(--tabiya-green);
            color: var(--oxford-blue);
            border-radius: 3px;
            font-weight: bold;
            position: absolute;
            left: 2px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
        }

        /* Tree node positioning for badges */
        .tree-node {
            position: relative;
            padding-left: 24px; /* Extra space for badge */
        }

        .tree-node.localized-item {
            border-left: 3px solid var(--tabiya-green);
        }

        * {
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

    </style>

</head>
<body>
    <!-- Debug indicator -->
    <div class="debug-info" id="debugInfo">Navigation Fixes Applied ✅</div>

    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="logo-section">
                <img src="./assets/images/tabiya_logo_icononly.png" alt="Tabiya Logo" class="logo-image">
                <div>
                    <h1>Inclusive Livelihoods Taxonomy</h1>
                    <p>Making visible and usable the human capital of everyone in an economy</p>
                </div>
            </div>
            <div class="header-actions">
                <div class="language-switcher">
                    <button class="lang-btn active" onclick="switchLanguage('en')" id="lang-en">EN</button>
                    <button class="lang-btn" onclick="switchLanguage('es')" id="lang-es">ES</button>
                </div>
                <a href="https://tabiya.org" class="btn-header" target="_blank">
                    <i class="fas fa-external-link-alt"></i> Learn More
                </a>
                <a href="https://github.com/tabiya-tech" class="btn-header" target="_blank">
                    <i class="fab fa-github"></i> GitHub
                </a>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="main-content">
            <!-- Enhanced Navigation with Main tabs and Sub-tabs -->
            <div class="top-nav">
                <!-- Header with tabs and export button -->
                <div class="nav-header">
                    <!-- Main tabs with binder design -->
                    <ul class="nav-tabs">
                        <li class="nav-tab active" onclick="switchMainTab('about', this)">
                            <i class="fas fa-info-circle"></i> About
                        </li>
                    <li class="nav-tab" onclick="switchMainTab('occupations', this)">
                            <i class="fas fa-briefcase"></i> Occupations
                        </li>
                        <li class="nav-tab" onclick="switchMainTab('skills', this)">
                            <i class="fas fa-tools"></i> Skills
                        </li>
                    </ul>
                    
                    <div style="display: flex; gap: 16px; align-items: center;">
                        <!-- Localization selector (English only) -->
                        <div class="localization-selector" id="localizationSelector" style="display: none;">
                            <button class="loc-btn active" onclick="switchLocalization(null)" id="loc-base">
                                🌍 Global
                            </button>
                            <button class="loc-btn" onclick="switchLocalization('za')" id="loc-za">
                                🇿🇦 South Africa
                            </button>
                        </div>
                        
                        <!-- Export button -->
                        <button class="export-button" onclick="exportData()">
                            <i class="fas fa-download"></i> Export
                        </button>
                    </div>
                </div>
                
                <!-- Sub-tabs for Occupations -->
                <ul class="sub-nav-tabs" id="occupations-subtabs">
                    <li class="sub-nav-tab active" onclick="switchSubTab('seen-occupations', this)">
                        <i class="fas fa-eye"></i> Seen Economy
                    </li>
                    <li class="sub-nav-tab" onclick="switchSubTab('unseen-occupations', this)">
                        <i class="fas fa-eye-slash"></i> Unseen Economy
                    </li>
                </ul>
                
                <!-- Sub-tabs for Skills (hidden initially) -->
                <ul class="sub-nav-tabs" id="skills-subtabs">
                    <!-- Skills will only have one view, so no sub-tabs needed -->
                </ul>
            </div>

            <!-- Explorer Layout -->
            <div class="explorer-layout">
                <!-- Sidebar -->
                <div class="sidebar">
                    <div class="search-section">
                        <input type="text" class="search-box" id="searchBox" 
                               placeholder="Search taxonomy..." autocomplete="off">
                        <div class="search-stats" id="searchStats"></div>
                    </div>

                    <div id="treeContainer" class="tree-container">
                        <div class="loading">
                            <i class="fas fa-spinner"></i>
                            <div>Loading taxonomy...</div>
                        </div>
                    </div>
                </div>

                <!-- Main Panel -->
                <div class="main-panel">
                    <div id="detailPanel">
                        <div class="empty-state">
                            <i class="fas fa-mouse-pointer"></i>
                            <h3>Select an item to explore</h3>
                            <p>Click on an occupation, group, or skill from the sidebar to view detailed information, relationships, and required skills.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Multi-language system
        let currentLanguage = 'en';
        let currentLocalization = null;
        let translations = {};
        
        // Global state
        let baseData = {};
        let localizedData = {};
        let taxonomyData = {
            occupations: [],
            groups: [],
            skills: [],
            skillGroups: [],
            occupationToSkills: [],
            hierarchy: {},
            skillHierarchy: {}
        };
        
        let urlState = {
            lang: 'en',           // en | es
            localization: 'base', // base | za  
            taxonomy: 'about',    // about | occupations | skills
            itemId: null,         // MongoDB ObjectId from CSV
            searchQuery: null     // for search URLs
        };

        let currentMainTab = 'about';
        let currentSubTab = 'seen-occupations';
        let selectedItem = null;
        let searchTimeout = null;

        // Performance optimization instances
        let dataWorker = null;
        let performanceManager = null;
        let progressUI = null;
        let virtualScrollers = new Map();
        let isDataLoading = false;


        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializePerformanceOptimizations();
            loadTranslations();
            setupEventListeners();
            
            // NEW: Initialize from URL
            initializeFromURL();
        });

        function initializeFromURL() {
            const currentState = parseURL(window.location.pathname, window.location.search);
            urlState = currentState;
            
            // Set app state from URL
            currentLanguage = currentState.lang;
            currentLocalization = currentState.localization === 'base' ? null : currentState.localization;
            
            // Update UI to match URL
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`lang-${currentState.lang}`).classList.add('active');
            
            if (currentState.localization !== 'base') {
                document.querySelectorAll('.loc-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`loc-${currentState.localization}`).classList.add('active');
            }
            
            // Set taxonomy tab
            if (currentState.taxonomy !== 'about') {
                currentMainTab = currentState.taxonomy;
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                
                if (currentState.taxonomy === 'occupations') {
                    document.querySelector('.nav-tab:nth-child(2)').classList.add('active');
                } else if (currentState.taxonomy === 'skills') {
                    document.querySelector('.nav-tab:nth-child(3)').classList.add('active');
                }
            }
            
            // Load data and then handle item selection
            loadTaxonomyData().then(() => {
                if (currentState.itemId) {
                    selectItemById(currentState.itemId);
                } else if (currentState.searchQuery) {
                    document.getElementById('searchBox').value = currentState.searchQuery;
                    performSearch();
                }
            });
        }

        // Initialize performance optimization components
        function initializePerformanceOptimizations() {
            
            // Initialize Performance Manager
            performanceManager = new PerformanceManager({
                chunkSize: 200,
                frameBudget: 16,
                yieldThreshold: 10,
                progressCallback: updateLoadingProgress
            });
            
            // Initialize Progress UI
            const mainContent = document.querySelector('.main-content');
            progressUI = new ProgressUI(mainContent);
            
            // Initialize Web Worker
            initializeDataWorker();
            
        }

        // Initialize the data processing web worker
        function initializeDataWorker() {
            try {
                dataWorker = new Worker('data-worker.js');
                
                dataWorker.onmessage = function(e) {
                    const { type, data } = e.data;
                    
                    switch (type) {
                        case 'WORKER_READY':
                            break;
                        case 'PROGRESS_UPDATE':
                            updateLoadingProgress(data.progress);
                            break;
                        case 'SEARCH_COMPLETE':
                            handleSearchComplete(data);
                            break;
                        case 'ERROR':
                            console.error("Worker error:", data.error);
                            break;
                    }
                };
                
                dataWorker.onerror = function(error) {
                    console.error("Worker error:", error);
                    dataWorker = null;
                };
                
            } catch (error) {
                console.warn("Web Worker not supported, using main thread:", error);
                dataWorker = null;
            }
        }

        

        // Update loading progress UI
        function updateLoadingProgress(progress) {
            if (progressUI && progressUI.isVisible) {
                progressUI.update(progress);
            }
            
            const debugInfo = document.getElementById('debugInfo');
            if (debugInfo && progress.phase) {
                debugInfo.textContent = `${progress.phase}: ${progress.percentage || 0}% ⏳`;
            }
        }

        // Set initial localization button visibility
        setTimeout(() => {
            updateLocalizationVisibility();
        }, 100);

        function setupEventListeners() {
            const searchBox = document.getElementById('searchBox');
            searchBox.addEventListener('input', debounce(performSearch, 300));

            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'f') {
                    e.preventDefault();
                    searchBox.focus();
                }
            });
        }

        async function loadTranslations() {
            try {                
                // Load both language files
                const [enResponse, esResponse] = await Promise.all([
                    fetch('./locales/en.json'),
                    fetch('./locales/es.json')
                ]);

                if (enResponse.ok && esResponse.ok) {
                    translations.en = await enResponse.json();
                    translations.es = await esResponse.json();
                                    
                    // Update UI with current language
                    updateUITranslations();
                    
                    // Load taxonomy data after translations are ready
                    loadTaxonomyData();
                } else {
                    console.warn("⚠️ Could not load translation files, using defaults");
                    loadTaxonomyData();
                }
            } catch (error) {
                console.error("❌ Error loading translations:", error);
                loadTaxonomyData();
            }
        }

        function updateUITranslations() {
            const elements = document.querySelectorAll('[data-i18n]');
            elements.forEach(el => {
                const key = el.getAttribute('data-i18n');
                const translation = getTranslation(key);
                if (translation) {
                    el.textContent = translation;
                }
            });

            // Update placeholders
            const placeholderElements = document.querySelectorAll('[data-i18n-placeholder]');
            placeholderElements.forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                const translation = getTranslation(key);
                if (translation) {
                    el.placeholder = translation;
                }
            });

            console.log(`🌍 UI updated to ${currentLanguage.toUpperCase()}`);
        }

        function getTranslation(key) {
            const keys = key.split('.');
            let value = translations[currentLanguage];
            
            for (const k of keys) {
                if (value && typeof value === 'object') {
                    value = value[k];
                } else {
                    return null;
                }
            }
            
            return value || null;
        }

        async function switchLanguage(lang) {
            if (lang === currentLanguage) return;
            updateURL({ lang: lang });
            console.log(`🌍 Switching language from ${currentLanguage} to ${lang}`);
            
            currentLanguage = lang;
            
            // Update language buttons
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`lang-${lang}`).classList.add('active');
            
            // Show/hide localization selector based on language
            updateLocalizationVisibility();
            
            // If switching away from English, reset to global
            if (lang !== 'en' && currentLocalization) {
                console.log(`🌍 Switching away from English, resetting to Global localization`);
                currentLocalization = null;
                document.querySelectorAll('.loc-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById('loc-base').classList.add('active');
            }
            
            // Update UI translations first
            updateUITranslations();
            
            // Show loading indicator
            const container = document.getElementById('treeContainer');
            if (container && currentMainTab !== 'about') {
                container.innerHTML = `
                    <div class="loading" style="text-align: center; padding: 40px;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--oxford-blue); margin-bottom: 16px;"></i>
                        <div style="color: var(--text-muted);">Loading ${lang.toUpperCase()} taxonomy...</div>
                        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">Loading from ./data/base/${lang}/</div>
                    </div>
                `;
            }
            
            try {
                // Clear existing data to force fresh load
                taxonomyData = { stats: {} };
                
                // Reload taxonomy data for new language
                await loadTaxonomyData();
                
                // Re-render the current view
                if (currentMainTab === 'about') {
                    showAboutPanel();
                } else if (currentMainTab === 'skills') {
                    await renderSkillsTreeOptimized();
                    showSkillsOverview();
                } else {
                    await renderTaxonomyTreeOptimized();
                    showOccupationsOverview();
                }
                updateSearchStats();
                updateTabBadges();
                
                console.log(`✅ Language switched to ${lang.toUpperCase()}`);
                
                // Update debug info
                document.getElementById('debugInfo').textContent = `Language: ${lang.toUpperCase()} ✅`;
                
            } catch (error) {
                console.error("❌ Error switching language:", error);
                
                // Show error state
                if (container && currentMainTab !== 'about') {
                    container.innerHTML = `
                        <div class="error-state" style="text-align: center; padding: 40px;">
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem; color: #ffc107; margin-bottom: 16px;"></i>
                            <h3>Failed to Load Language</h3>
                            <p>Could not load ${lang.toUpperCase()} data from ./data/base/${lang}/</p>
                            <p style="font-size: 14px; margin-top: 12px;">Error: ${error.message}</p>
                            <button onclick="switchLanguage('en')" class="btn-control" style="margin-top: 20px;">
                                <i class="fas fa-language"></i> Switch to English
                            </button>
                        </div>
                    `;
                }
                
                // Reset to English on error
                currentLanguage = 'en';
                document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById('lang-en').classList.add('active');
            }
        }

        async function switchLocalization(localization) {
            if (localization === currentLocalization) return;
            updateURL({ localization: localization || 'base' });
            console.log(`🌍 Switching localization from ${currentLocalization || 'base'} to ${localization || 'base'}`);
            
            currentLocalization = localization;
            
            // Update localization buttons
            document.querySelectorAll('.loc-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`loc-${localization || 'base'}`).classList.add('active');
            
            // Show loading indicator
            const container = document.getElementById('treeContainer');
            if (container) {
                container.innerHTML = `
                    <div class="loading" style="text-align: center; padding: 40px;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--oxford-blue); margin-bottom: 16px;"></i>
                        <div style="color: var(--text-muted);">Loading ${localization ? localization.toUpperCase() : 'base'} data...</div>
                    </div>
                `;
            }
            
            try {
                // Reload data with new localization
                await loadTaxonomyData();
                
                console.log(`✅ Localization switched to ${localization || 'Base'}`);
                
                // Update debug info
                document.getElementById('debugInfo').textContent = `${localization || 'Base'} + ${currentLanguage.toUpperCase()} ✅`;
                
            } catch (error) {
                console.error("❌ Error switching localization:", error);
                
                // Show error state
                if (container) {
                    container.innerHTML = `
                        <div class="error-state" style="text-align: center; padding: 40px;">
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem; color: #ffc107; margin-bottom: 16px;"></i>
                            <h3>Failed to Load Localization</h3>
                            <p>Could not load ${localization || 'base'} data: ${error.message}</p>
                            <button onclick="switchLocalization(null)" class="btn-control" style="margin-top: 20px;">
                                <i class="fas fa-globe"></i> Switch to Global
                            </button>
                        </div>
                    `;
                }
            }
        }

        function updateLocalizationVisibility() {
            const localizationSelector = document.getElementById('localizationSelector');
            if (localizationSelector) {
                // Only show when English is selected
                localizationSelector.style.display = currentLanguage === 'en' ? 'flex' : 'none';
                
                console.log(`🌍 Localization buttons ${currentLanguage === 'en' ? 'shown' : 'hidden'} for language: ${currentLanguage}`);
            }
        }

        function isLocalizedContent(item) {
            return item.ISLOCALIZED === 'TRUE' || item.ISLOCALIZED === true || item.isLocalized === true;
        }

        function getLocalizationChanges(baseItem, localizedItem) {
            const changes = {};
            
            if (!baseItem && localizedItem) {
                // Completely new item
                changes.type = 'new';
                changes.isNew = true;
            } else if (baseItem && localizedItem) {
                // Modified item - check what changed
                changes.type = 'modified';
                changes.isNew = false;
                
                // Check alt labels
                if (localizedItem.altLabels !== baseItem.altLabels) {
                    changes.altLabelsAdded = getAddedAltLabels(baseItem.altLabels, localizedItem.altLabels);
                }
                
                // Check description changes
                if (localizedItem.description !== baseItem.description) {
                    changes.descriptionChanged = true;
                }
            }
            
            return changes;
        }

        function getAddedAltLabels(baseLabels, localizedLabels) {
            if (!baseLabels) return localizedLabels;
            if (!localizedLabels) return '';
            
            const baseSet = new Set(baseLabels.split(/[,\n]/).map(l => l.trim().toLowerCase()));
            const localizedSet = localizedLabels.split(/[,\n]/).map(l => l.trim());
            
            return localizedSet.filter(label => !baseSet.has(label.toLowerCase())).join(', ');
        }

        // Enhanced data loading with REAL CSV files and FIXED skills integration
        async function loadOriginalTaxonomyData() {
            
            try {
                // Show loading indicator
                const container = document.getElementById('treeContainer');
                if (container) {
                    container.innerHTML = `
                        <div class="loading" style="text-align: center; padding: 40px;">
                            <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--oxford-blue); margin-bottom: 16px;"></i>
                            <div style="color: var(--text-muted);">Loading taxonomy from CSV files...</div>
                            <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">Loading 7 data files...</div>
                        </div>
                    `;
                }

                
                // Use language-specific data folder
                const dataPath = `./data/${currentLanguage}`;
                
                // Load all CSV files
                const [
                    occupationsResponse, 
                    groupsResponse, 
                    hierarchyResponse,
                    skillsResponse,
                    skillGroupsResponse,
                    skillHierarchyResponse,
                    occupationToSkillsResponse
                ] = await Promise.all([
                    fetch(`${dataPath}/occupations.csv`),
                    fetch(`${dataPath}/occupation_groups.csv`),
                    fetch(`${dataPath}/occupation_hierarchy.csv`),
                    fetch(`${dataPath}/skills.csv`),
                    fetch(`${dataPath}/skill_groups.csv`),
                    fetch(`${dataPath}/skill_hierarchy.csv`),
                    fetch(`${dataPath}/occupation_to_skill_relations.csv`)
                ]);

                // Check if all files loaded successfully
                const responses = [
                    { name: 'occupations', response: occupationsResponse },
                    { name: 'groups', response: groupsResponse },
                    { name: 'hierarchy', response: hierarchyResponse },
                    { name: 'skills', response: skillsResponse },
                    { name: 'skill_groups', response: skillGroupsResponse },
                    { name: 'skill_hierarchy', response: skillHierarchyResponse },
                    { name: 'occupation_to_skills', response: occupationToSkillsResponse }
                ];

                for (const {name, response} of responses) {
                    if (!response.ok) {
                        throw new Error(`Failed to load ${name}.csv: ${response.status} ${response.statusText}`);
                    }
                }

                // Get text content from all files
                const [
                    occupationsText, 
                    groupsText, 
                    hierarchyText,
                    skillsText,
                    skillGroupsText,
                    skillHierarchyText,
                    occupationToSkillsText
                ] = await Promise.all([
                    occupationsResponse.text(),
                    groupsResponse.text(),
                    hierarchyResponse.text(),
                    skillsResponse.text(),
                    skillGroupsResponse.text(),
                    skillHierarchyResponse.text(),
                    occupationToSkillsResponse.text()
                ]);

                console.log("✅ All CSV files loaded successfully");

                // Parse all CSV data using Papa Parse with CODE field preservation
                const parseOptions = {
                    header: true,
                    dynamicTyping: (field) => {
                        // Don't convert CODE fields to numbers to preserve leading zeros
                        const codeFields = ['CODE', 'OCCUPATIONGROUPCODE', 'PARENTID', 'CHILDID', 'OCCUPATIONID', 'SKILLID'];
                        return !codeFields.includes(field);
                    },
                    skipEmptyLines: true,
                    transformHeader: (header) => header.trim()
                };

                const occupationsParsed = Papa.parse(occupationsText, parseOptions);
                const groupsParsed = Papa.parse(groupsText, parseOptions);
                const hierarchyParsed = Papa.parse(hierarchyText, parseOptions);
                const skillsParsed = Papa.parse(skillsText, parseOptions);
                const skillGroupsParsed = Papa.parse(skillGroupsText, parseOptions);
                const skillHierarchyParsed = Papa.parse(skillHierarchyText, parseOptions);
                const occupationToSkillsParsed = Papa.parse(occupationToSkillsText, parseOptions);


                // Process occupations
                const processedOccupations = occupationsParsed.data
                    .filter(occ => occ.CODE && occ.PREFERREDLABEL)
                    .map(occ => {
                        const code = occ.CODE.toString().trim();
                        const isUnseen = code.startsWith('I');
                        
                        return {
                            id: occ.ID,
                            code: code,
                            label: occ.PREFERREDLABEL.trim(),
                            description: occ.DESCRIPTION ? occ.DESCRIPTION.substring(0, 300).trim() : '',
                            altLabels: occ.ALTLABELS ? occ.ALTLABELS.trim() : '',
                            type: isUnseen ? 'unseen' : 'seen',
                            groupCode: occ.OCCUPATIONGROUPCODE ? occ.OCCUPATIONGROUPCODE.toString().trim() : '',
                            occupationType: occ.OCCUPATIONTYPE || ''
                        };
                    });

                // Build hierarchy maps
                const groupById = {};
                const occById = {};
                
                groupsParsed.data.forEach(group => {
                    if (group.ID) groupById[group.ID] = group;
                });
                
                processedOccupations.forEach(occ => {
                    if (occ.id) occById[occ.id] = occ;
                });

                const hierarchyMap = {};
                const parentMap = {};
                
                hierarchyParsed.data.forEach(rel => {
                    if (rel.PARENTID && rel.CHILDID) {
                        if (!hierarchyMap[rel.PARENTID]) {
                            hierarchyMap[rel.PARENTID] = [];
                        }
                        hierarchyMap[rel.PARENTID].push(rel.CHILDID);
                        parentMap[rel.CHILDID] = rel.PARENTID;
                    }
                });

                // Process groups
                const processedGroups = groupsParsed.data
                    .filter(group => group.CODE && group.PREFERREDLABEL)
                    .map(group => {
                        const code = group.CODE.toString().trim();
                        const isUnseen = code.startsWith('I');
                        
                        let level = 1;
                        if (isUnseen) {
                            if (code.includes('_')) {
                                const parts = code.split('_');
                                level = parts.length + 1;
                            } else if (code.length > 2) {
                                level = 2;
                            }
                        } else {
                            const cleanCode = code.replace(/^0+/, '');
                            level = Math.max(1, cleanCode.length);
                        }
                        
                        const childIds = hierarchyMap[group.ID] || [];
                        const children = childIds.map(childId => {
                            const childGroup = groupById[childId];
                            const childOcc = occById[childId];
                            
                            if (childGroup && childGroup.CODE) {
                                return childGroup.CODE.toString().trim();
                            }
                            if (childOcc && childOcc.code) {
                                return childOcc.code;
                            }
                            return null;
                        }).filter(Boolean);
                        
                        const parentId = parentMap[group.ID];
                        const parent = parentId ? groupById[parentId] : null;
                        const parentCode = parent && parent.CODE ? parent.CODE.toString().trim() : undefined;
                        
                        return {
                            id: group.ID,
                            code: code,
                            label: group.PREFERREDLABEL.trim(),
                            description: group.DESCRIPTION ? group.DESCRIPTION.substring(0, 400).trim() : '',
                            altLabels: group.ALTLABELS ? group.ALTLABELS.trim() : '',
                            type: isUnseen ? 'unseen' : 'seen',
                            level: level,
                            groupType: group.GROUPTYPE || '',
                            children: children,
                            parent: parentCode
                        };
                    });

                // Create skills master from skill_hierarchy.csv as foundation
                // Step 1: Build hierarchy maps using MongoDB IDs
                const skillHierarchyMap = {};
                const skillParentMap = {};
                
                skillHierarchyParsed.data.forEach(rel => {
                    if (rel.PARENTID && rel.CHILDID) {
                        // Parent to children map
                        if (!skillHierarchyMap[rel.PARENTID]) {
                            skillHierarchyMap[rel.PARENTID] = [];
                        }
                        skillHierarchyMap[rel.PARENTID].push(rel.CHILDID);
                        
                        // Child to parent map
                        skillParentMap[rel.CHILDID] = rel.PARENTID;
                    }
                });

                // Step 2: Create lookup maps for enrichment
                const skillDataById = {};
                const skillGroupDataById = {};
                
                // Index skills by ID
                skillsParsed.data.forEach(skill => {
                    if (skill.ID) {
                        skillDataById[skill.ID] = skill;
                    }
                });
                
                // Index skill groups by ID
                skillGroupsParsed.data.forEach(group => {
                    if (group.ID) {
                        skillGroupDataById[group.ID] = group;
                    }
                });

                // Step 3: Create Skills Master - each CHILDID from hierarchy becomes an enriched item
                const skillsMaster = {};
                const allChildIds = new Set();
                
                // Collect all CHILDIDs from hierarchy
                skillHierarchyParsed.data.forEach(rel => {
                    if (rel.CHILDID) {
                        allChildIds.add(rel.CHILDID);
                    }
                });

                // Enrich each CHILDID with data from skills/skill_groups CSVs
                allChildIds.forEach(childId => {
                    let enrichedItem = {
                        id: childId,
                        parentId: skillParentMap[childId],
                        childrenIds: skillHierarchyMap[childId] || []
                    };

                    // Check if it's a skill or skill group
                    const skillData = skillDataById[childId];
                    const skillGroupData = skillGroupDataById[childId];

                    if (skillData) {
                        // It's an individual skill
                        enrichedItem = {
                            ...enrichedItem,
                            type: 'skill',
                            label: skillData.PREFERREDLABEL?.trim() || 'Unknown Skill',
                            description: skillData.DESCRIPTION?.substring(0, 300).trim() || '',
                            altLabels: skillData.ALTLABELS?.trim() || '',
                            skillType: skillData.SKILLTYPE || 'General',
                            reuseLevel: skillData.REUSELEVEL || '',
                            isClickable: true,
                            isSearchable: false // Individual skills not searchable
                        };
                    } else if (skillGroupData) {
                        // It's a skill group
                        let code = skillGroupData.CODE?.toString().trim() || childId;
                        let category = 'Other';
                        
                        // Determine category from CODE
                        if (code.startsWith('S')) {
                            category = 'Skills and competencies';
                        } else if (code.startsWith('L')) {
                            category = 'Language';
                        } else if (code.startsWith('T')) {
                            category = 'Transversal skills';
                        } else if (skillGroupData.ORIGINURI?.includes('isced-f')) {
                            category = 'Knowledge';
                            const match = skillGroupData.ORIGINURI.match(/isced-f\/(\d+)/);
                            if (match) {
                                code = match[1];
                            }
                        }

                        enrichedItem = {
                            ...enrichedItem,
                            type: 'skillgroup',
                            code: code,
                            label: skillGroupData.PREFERREDLABEL?.trim() || 'Unknown Group',
                            description: skillGroupData.DESCRIPTION?.substring(0, 300).trim() || '',
                            altLabels: skillGroupData.ALTLABELS?.trim() || '',
                            category: category,
                            isClickable: true,
                            isSearchable: true
                        };
                    } else {
                        // Orphaned hierarchy item
                        console.warn(`⚠️ Orphaned hierarchy item: ${childId}`);
                        enrichedItem = {
                            ...enrichedItem,
                            type: 'unknown',
                            label: `Unknown Item (${childId})`,
                            isClickable: false,
                            isSearchable: false
                        };
                    }

                    skillsMaster[childId] = enrichedItem;
                });

                // Step 4: Separate into skills and skill groups for compatibility
                const processedSkills = Object.values(skillsMaster).filter(item => item.type === 'skill');
                const processedSkillGroups = Object.values(skillsMaster).filter(item => 
                    item.type === 'skillgroup' && item.category !== 'Other'
                );

                // Process occupation-to-skill relationships with proper ID mapping
                const processedOccupationToSkills = occupationToSkillsParsed.data
                    .filter(rel => {
                        const hasOccId = rel.OCCUPATIONID && rel.OCCUPATIONID.toString().trim();
                        const hasSkillId = rel.SKILLID && rel.SKILLID.toString().trim();
                        return hasOccId && hasSkillId;
                    })
                    .map(rel => ({
                        occupationId: rel.OCCUPATIONID.toString().trim(),
                        skillId: rel.SKILLID.toString().trim(),
                        relationType: rel.RELATIONTYPE || 'related',
                        signallingValue: rel.SIGNALLINGVALUE || 0,
                        signallingValueLabel: rel.SIGNALLINGVALUELABEL || ''
                    }));

                // Create ID-to-Code mapping for lookups
                const occupationIdToCode = {};
                processedOccupations.forEach(occ => {
                    if (occ.id) occupationIdToCode[occ.id] = occ.code;
                });

                const skillIdToCode = {};
                processedSkills.forEach(skill => {
                    if (skill.id) skillIdToCode[skill.id] = skill.code;
                });

                // Calculate statistics
                const unseenOccs = processedOccupations.filter(o => o.type === 'unseen');
                const seenOccs = processedOccupations.filter(o => o.type === 'seen');
                const unseenGroups = processedGroups.filter(g => g.type === 'unseen');
                const seenGroups = processedGroups.filter(g => g.type === 'seen');

                const stats = {
                    totalOccupations: processedOccupations.length,
                    totalGroups: processedGroups.length,
                    totalSkills: processedSkills.length,
                    totalSkillGroups: processedSkillGroups.length,
                    totalItems: processedOccupations.length + processedGroups.length + processedSkills.length,
                    unseenOccupations: unseenOccs.length,
                    unseenGroups: unseenGroups.length,
                    unseenTotal: unseenOccs.length + unseenGroups.length,
                    seenOccupations: seenOccs.length,
                    seenGroups: seenGroups.length,
                    seenTotal: seenOccs.length + seenGroups.length,
                    occupationSkillRelations: processedOccupationToSkills.length
                };

                // Set global taxonomy data with Skills Master
                taxonomyData = {
                    occupations: processedOccupations,
                    groups: processedGroups,
                    skills: processedSkills,
                    skillGroups: processedSkillGroups,
                    occupationToSkills: processedOccupationToSkills,
                    stats: stats,
                    // Add lookup maps for ID-Code conversion
                    occupationIdToCode: occupationIdToCode,
                    skillIdToCode: skillIdToCode,
                    // Add reverse lookups for skill navigation
                    occupationCodeToId: Object.fromEntries(Object.entries(occupationIdToCode).map(([id, code]) => [code, id])),
                    skillCodeToId: Object.fromEntries(Object.entries(skillIdToCode).map(([id, code]) => [code, id])),
                    // Skills Master and hierarchy maps
                    skillsMaster: skillsMaster,
                    skillHierarchyMap: skillHierarchyMap,
                    skillParentMap: skillParentMap
                };

                // Update debug info
                document.getElementById('debugInfo').textContent = 'Navigation Fixes Applied ✅';

                // Render the taxonomy tree
                showAboutPanel(); // Start with About tab active
                updateSearchStats();
                updateTabBadges();

            } catch (error) {
                console.error("❌ Failed to load CSV files:", error);

                // ALWAYS show About panel first when on About tab
                if (currentMainTab === 'about') {
                    showAboutPanel();
                }

                // Only show error in tree container if NOT on About tab
                if (currentMainTab !== 'about') {
                    const container = document.getElementById('treeContainer');
                    if (container) {
                        container.innerHTML = `
                            <div class="error-state" style="text-align: center; padding: 40px; color: var(--text-secondary);">
                                <i class="fas fa-exclamation-triangle" style="font-size: 2rem; color: #ffc107; margin-bottom: 16px;"></i>
                                <h3>Failed to Load CSV Files</h3>
                                <p>Error: ${error.message}</p>
                                <p style="font-size: 14px; margin-top: 12px;">Make sure the data/ folder contains all required CSV files and the server is running.</p>
                                <button onclick="location.reload()" class="btn-control" style="margin-top: 20px;">
                                    <i class="fas fa-refresh"></i> Retry
                                </button>
                            </div>
                        `;
                    }
                }
            }
            if (currentMainTab === 'about') {
                showAboutPanel();
            }
            // Update tab badges (they have fallback values)
            updateTabBadges();
        }
        

        async function loadTaxonomyData() {
            if (isDataLoading) {
                return;
            }
            
            isDataLoading = true;
            console.log(`🚀 Loading ${currentLanguage.toUpperCase()} taxonomy data...`);
            
            try {
                // Determine the correct data path based on language and localization
                let dataPath;
                
                // Get the base path for GitHub Pages deployment
                const basePath = window.location.hostname === 'tabiya-tech.github.io' 
                    ? '/tabiya-taxonomy-explorer' 
                    : '';

                if (currentLocalization === 'za' && currentLanguage === 'en') {
                    // South African English
                    dataPath = `${basePath}/data/localized/za/en`;
                } else {
                    // Base language data (en or es)
                    dataPath = `${basePath}/data/base/${currentLanguage}`;
                }

                
                // Load the appropriate data
                baseData = await loadDataFromPath(dataPath);
                
                // For localization, we need to also load base data for comparison
                if (currentLocalization === 'za') {
                    try {
                        const baseEnglishData = await loadDataFromPath('./data/base/en');
                        
                        // Mark localization differences
                        markLocalizationDifferences(baseEnglishData, baseData);
                    } catch (locError) {
                        console.warn("⚠️ Could not load base English data for comparison:", locError);
                    }
                }
                
                // Set the global taxonomy data
                taxonomyData = baseData;
                
                
            } catch (error) {
                console.error("❌ Failed to load taxonomy data:", error);
                
                // Show error in UI only if not on About tab
                if (currentMainTab !== 'about') {
                    const container = document.getElementById('treeContainer');
                    if (container) {
                        container.innerHTML = `
                            <div class="error-state" style="text-align: center; padding: 40px; color: var(--text-secondary);">
                                <i class="fas fa-exclamation-triangle" style="font-size: 2rem; color: #ffc107; margin-bottom: 16px;"></i>
                                <h3>Failed to Load Data</h3>
                                <p>Error: ${error.message}</p>
                                <p style="font-size: 14px; margin-top: 12px;">Expected file structure: ./data/base/${currentLanguage}/*.csv</p>
                                <button onclick="loadTaxonomyData()" class="btn-control" style="margin-top: 20px;">
                                    <i class="fas fa-refresh"></i> Retry
                                </button>
                            </div>
                        `;
                    }
                }
            } finally {
                isDataLoading = false;
                
                // Update UI after data loading (successful or failed)
                if (currentMainTab === 'about') {
                    showAboutPanel();
                } else if (currentMainTab === 'skills') {
                    await renderSkillsTreeOptimized();
                    showSkillsOverview();
                } else {
                    await renderTaxonomyTreeOptimized();
                    showOccupationsOverview();
                }
                updateSearchStats();
                updateTabBadges();

                // CRITICAL: Apply font corruption fixes after any tree rendering
                setTimeout(() => {
                    applyFontFixes();
                }, 100);
            }
        }


        // Optimized data loading with progressive loading
        async function loadDataFromPathOptimized(dataPath) {
            
            // Define data sources with priorities
            const dataSources = {
                occupations: {
                    url: `${dataPath}/occupations.csv`,
                    priority: 1,
                    description: 'occupation data'
                },
                groups: {
                    url: `${dataPath}/occupation_groups.csv`,
                    priority: 1,
                    description: 'occupation groups'
                },
                hierarchy: {
                    url: `${dataPath}/occupation_hierarchy.csv`,
                    priority: 2,
                    description: 'hierarchy relationships'
                },
                skills: {
                    url: `${dataPath}/skills.csv`,
                    priority: 3,
                    description: 'skills data'
                },
                skillGroups: {
                    url: `${dataPath}/skill_groups.csv`,
                    priority: 3,
                    description: 'skill groups'
                },
                skillHierarchy: {
                    url: `${dataPath}/skill_hierarchy.csv`,
                    priority: 4,
                    description: 'skill hierarchy'
                },
                occupationToSkills: {
                    url: `${dataPath}/occupation_to_skill_relations.csv`,
                    priority: 5,
                    description: 'skill relationships'
                }
            };
            
            // Load data progressively
            const rawData = await performanceManager.loadDataProgressively(dataSources, {
                progressCallback: (progress) => {
                    progressUI.update({
                        phase: progress.phase,
                        message: progress.message
                    });
                }
            });
            
            // Process data using main thread with chunking (worker integration can be added later)
            return await processDataMainThread(rawData);
        }

        // Process data on main thread with chunking
        async function processDataMainThread(rawData) {
            const processedData = {
                occupations: [],
                groups: [],
                skills: [],
                skillGroups: [],
                occupationToSkills: [],
                skillsMaster: {},
                stats: {}
            };
            
            // Process each CSV with chunking
            const processors = {
                occupations: processOccupationRow,
                groups: processGroupRow,
                skills: processSkillRow,
                skillGroups: processSkillGroupRow,
                hierarchy: processHierarchyRow,
                skillHierarchy: processSkillHierarchyRow,
                occupationToSkills: processOccupationToSkillRow
            };
            
            for (const [dataType, csvText] of Object.entries(rawData)) {
                progressUI.update({
                    phase: `Processing ${dataType}`,
                    message: `Parsing ${dataType} data...`
                });
                
                // Parse CSV
                const parsed = Papa.parse(csvText, {
                    header: true,
                    dynamicTyping: (field) => {
                        const codeFields = ['CODE', 'OCCUPATIONGROUPCODE', 'PARENTID', 'CHILDID', 'OCCUPATIONID', 'SKILLID'];
                        return !codeFields.includes(field);
                    },
                    skipEmptyLines: true,
                    transformHeader: (header) => header.trim()
                });
                
                // Process in chunks
                const processor = processors[dataType];
                if (processor) {
                    const processed = await performanceManager.processInChunks(
                        parsed.data,
                        processor,
                        {
                            chunkSize: 500,
                            phase: `Processing ${dataType}`,
                            progressCallback: (progress) => {
                                progressUI.update({
                                    phase: `Processing ${dataType}`,
                                    percentage: Math.round(progress.percentage * 0.8),
                                    message: `${progress.processed}/${progress.total} items`
                                });
                            }
                        }
                    );
                    
                    processedData[dataType] = processed;
                }
            }
            
            // Build skills master
            progressUI.update({
                phase: 'Building Skills Master',
                percentage: 85,
                message: 'Creating skill hierarchy...'
            });
            
            processedData.skillsMaster = await buildSkillsMasterOptimized(
                processedData.skillHierarchy || [],
                processedData.skills || [],
                processedData.skillGroups || []
            );
            
            // Calculate stats
            progressUI.update({
                phase: 'Calculating Statistics',
                percentage: 95,
                message: 'Computing data metrics...'
            });
            
            processedData.stats = calculateStatsOptimized(processedData);
            
            return processedData;
        }

        // Initialize virtual scrollers for large datasets
        function initializeVirtualScrollers() {            
            virtualScrollers.clear();
            
            const treeContainer = document.getElementById('treeContainer');
            if (treeContainer) {
                const treeScroller = new TreeVirtualScroller(treeContainer, {
                    itemHeight: 48,
                    threshold: 200,
                    renderItem: renderVirtualTreeItem
                });
                virtualScrollers.set('tree', treeScroller);
            }
        }

        // Render tree item for virtual scroller
        function renderVirtualTreeItem(item, index, isSelected) {
            const selectedClass = isSelected ? 'selected' : '';
            const localizationClass = item.isLocalized ? 'localized-item' : '';
            const badge = item.isLocalized ? '<span class="localized-badge">ZA</span>' : '';
            
            const indent = (item.level || 0) * 24;
            const hasChildren = item.hasChildren || false;
            const toggleIcon = hasChildren ? 
                (item.isExpanded ? 'fa-chevron-down' : 'fa-chevron-right') : '';
            
            const code = item.code ? `<span class="tree-code">${item.code}</span>` : '';
            
            return `
                <div class="tree-node virtual-tree-item ${selectedClass} ${localizationClass}" 
                    data-index="${index}" 
                    data-code="${item.code || item.id}"
                    onclick="selectItem('${item.code || item.id}', '${item.type || 'occupation'}', event)"
                    style="padding-left: ${indent + 16}px;">
                    
                    ${badge}
                    
                    <div class="tree-toggle" onclick="toggleVirtualNode('${item.code || item.id}', event)">
                        ${toggleIcon ? `<i class="fas ${toggleIcon}"></i>` : ''}
                    </div>
                    
                    ${code}
                    
                    <span class="tree-label">${item.label}</span>
                </div>
            `;
        }


        async function loadDataFromPath(dataPath) {            
            const fileNames = [
                'occupations.csv',
                'occupation_groups.csv', 
                'occupation_hierarchy.csv',
                'skills.csv',
                'skill_groups.csv',
                'skill_hierarchy.csv',
                'occupation_to_skill_relations.csv'
            ];
            
            // Load all CSV files
            const responses = await Promise.all(
                fileNames.map(async (fileName) => {
                    // Ensure absolute path from site root
                    const fullPath = dataPath.startsWith('/') ? `${dataPath}/${fileName}` : `/${dataPath}/${fileName}`;                    
                    const response = await fetch(fullPath);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${fileName}: ${response.status} ${response.statusText}`);
                    }
                    
                    const text = await response.text();
                    return { fileName, text };
                })
            );

            // Extract text content by filename
            const csvTexts = {};
            responses.forEach(({ fileName, text }) => {
                const key = fileName.replace('.csv', '').replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
                csvTexts[key] = text;
            });

            // Parse all CSV data using Papa Parse with CODE field preservation
            const parseOptions = {
                header: true,
                dynamicTyping: (field) => {
                    // Don't convert ID/CODE fields to numbers to preserve leading zeros and MongoDB ObjectIds
                    const preserveFields = ['ID', 'CODE', 'OCCUPATIONGROUPCODE', 'PARENTID', 'CHILDID', 'OCCUPATIONID', 'SKILLID'];
                    return !preserveFields.includes(field);
                },
                skipEmptyLines: true,
                transformHeader: (header) => header.trim()
            };

            const occupationsParsed = Papa.parse(csvTexts.occupations, parseOptions);
            const groupsParsed = Papa.parse(csvTexts.occupationGroups, parseOptions);
            const hierarchyParsed = Papa.parse(csvTexts.occupationHierarchy, parseOptions);
            const skillsParsed = Papa.parse(csvTexts.skills, parseOptions);
            const skillGroupsParsed = Papa.parse(csvTexts.skillGroups, parseOptions);
            const skillHierarchyParsed = Papa.parse(csvTexts.skillHierarchy, parseOptions);
            const occupationToSkillsParsed = Papa.parse(csvTexts.occupationToSkillRelations, parseOptions);

        
            // ===== CRITICAL FIX: Build proper hierarchy maps from CSV =====            
            // Create ID lookup maps FIRST
            const groupById = {};
            const occById = {};
            
            groupsParsed.data.forEach(group => {
                if (group.ID) {
                    groupById[group.ID] = group;
                }
            });
            
            occupationsParsed.data.forEach(occ => {
                if (occ.ID) {
                    occById[occ.ID] = occ;
                }
            });

            // Build hierarchy maps using ACTUAL relationships from CSV (NOT string patterns)
            const hierarchyMap = {}; // parentId -> [childId1, childId2, ...]
            const parentMap = {};     // childId -> parentId
            
            hierarchyParsed.data.forEach(rel => {
                if (rel.PARENTID && rel.CHILDID) {
                    // Store parent -> children relationship
                    if (!hierarchyMap[rel.PARENTID]) {
                        hierarchyMap[rel.PARENTID] = [];
                    }
                    hierarchyMap[rel.PARENTID].push(rel.CHILDID);
                    
                    // Store child -> parent relationship
                    parentMap[rel.CHILDID] = rel.PARENTID;
                }
            });

            // Process occupations
            const processedOccupations = occupationsParsed.data
                .filter(occ => occ.CODE && occ.PREFERREDLABEL)
                .map(occ => {
                    const code = occ.CODE.toString().trim();
                    const isUnseen = code.startsWith('I');
                    
                    return {
                        id: occ.ID,
                        code: code,
                        label: occ.PREFERREDLABEL.trim(),
                        description: occ.DESCRIPTION ? occ.DESCRIPTION.substring(0, 300).trim() : '',
                        altLabels: occ.ALTLABELS ? occ.ALTLABELS.trim() : '',
                        type: isUnseen ? 'unseen' : 'seen',
                        groupCode: occ.OCCUPATIONGROUPCODE ? occ.OCCUPATIONGROUPCODE.toString().trim() : '',
                        occupationType: occ.OCCUPATIONTYPE || '',
                        ISLOCALIZED: occ.ISLOCALIZED || false
                    };
                });

            // ===== CRITICAL FIX: Process groups with PROPER parent assignment =====            
            const processedGroups = groupsParsed.data
                .filter(group => group.CODE && group.PREFERREDLABEL)
                .map(group => {
                    const code = group.CODE.toString().trim();
                    const isUnseen = code.startsWith('I');
                    
                    // ===== FIX: Calculate level based on ACTUAL hierarchy depth =====
                    let level = 1;
                    let currentId = group.ID;
                    let depth = 0;
                    
                    // Walk up the hierarchy to find actual depth
                    while (parentMap[currentId] && depth < 10) { // Safety limit
                        currentId = parentMap[currentId];
                        depth++;
                    }
                    level = depth + 1;
                    
                    // ===== FIX: Get children from ACTUAL hierarchy, not string matching =====
                    const childIds = hierarchyMap[group.ID] || [];
                    const children = childIds.map(childId => {
                        const childGroup = groupById[childId];
                        const childOcc = occById[childId];
                        
                        if (childGroup && childGroup.CODE) {
                            return childGroup.CODE.toString().trim();
                        }
                        if (childOcc && childOcc.CODE) {
                            return childOcc.CODE.toString().trim();
                        }
                        return null;
                    }).filter(Boolean);
                    
                    // ===== FIX: Get parent from ACTUAL hierarchy =====
                    const parentId = parentMap[group.ID];
                    const parent = parentId ? groupById[parentId] : null;
                    const parentCode = parent && parent.CODE ? parent.CODE.toString().trim() : undefined;
                    
                    return {
                        id: group.ID,
                        code: code,
                        label: group.PREFERREDLABEL.trim(),
                        description: group.DESCRIPTION ? group.DESCRIPTION.substring(0, 400).trim() : '',
                        altLabels: group.ALTLABELS ? group.ALTLABELS.trim() : '',
                        type: isUnseen ? 'unseen' : 'seen',
                        level: level, // From actual hierarchy - THIS FIXES I42 NESTING
                        groupType: group.GROUPTYPE || '',
                        children: children, // From actual hierarchy - THIS FIXES I42 NESTING
                        parent: parentCode, // From actual hierarchy - THIS FIXES I42 NESTING
                        ISLOCALIZED: group.ISLOCALIZED || false
                    };
                });

            // Build Skills Master from skill_hierarchy.csv            
            const skillHierarchyMap = {};
            const skillParentMap = {};
            
            skillHierarchyParsed.data.forEach(rel => {
                if (rel.PARENTID && rel.CHILDID) {
                    if (!skillHierarchyMap[rel.PARENTID]) {
                        skillHierarchyMap[rel.PARENTID] = [];
                    }
                    skillHierarchyMap[rel.PARENTID].push(rel.CHILDID);
                    skillParentMap[rel.CHILDID] = rel.PARENTID;
                }
            });

            // Create skill lookup maps
            const skillDataById = {};
            const skillGroupDataById = {};
            
            skillsParsed.data.forEach(skill => {
                if (skill.ID) skillDataById[skill.ID] = skill;
            });
            
            skillGroupsParsed.data.forEach(group => {
                if (group.ID) skillGroupDataById[group.ID] = group;
            });

            // Build Skills Master
            const skillsMaster = {};
            const allChildIds = new Set();
            
            skillHierarchyParsed.data.forEach(rel => {
                if (rel.CHILDID) allChildIds.add(rel.CHILDID);
            });

            allChildIds.forEach(childId => {
                let enrichedItem = {
                    id: childId,
                    parentId: skillParentMap[childId],
                    childrenIds: skillHierarchyMap[childId] || []
                };

                const skillData = skillDataById[childId];
                const skillGroupData = skillGroupDataById[childId];

                if (skillData) {
                    enrichedItem = {
                        ...enrichedItem,
                        type: 'skill',
                        label: skillData.PREFERREDLABEL?.trim() || 'Unknown Skill',
                        description: skillData.DESCRIPTION?.substring(0, 300).trim() || '',
                        altLabels: skillData.ALTLABELS?.trim() || '',
                        skillType: skillData.SKILLTYPE || 'General',
                        reuseLevel: skillData.REUSELEVEL || '',
                        isClickable: true,
                        isSearchable: false,
                        ISLOCALIZED: skillData.ISLOCALIZED || false
                    };
                } else if (skillGroupData) {
                    let code = skillGroupData.CODE?.toString().trim() || childId;
                    let category = 'Other';
                    
                    if (code.startsWith('S')) {
                        category = 'Skills and competencies';
                    } else if (code.startsWith('L')) {
                        category = 'Language';
                    } else if (code.startsWith('T')) {
                        category = 'Transversal skills';
                    } else if (skillGroupData.ORIGINURI?.includes('isced-f')) {
                        category = 'Knowledge';
                        const match = skillGroupData.ORIGINURI.match(/isced-f\/(\d+)/);
                        if (match) code = match[1];
                    }

                    enrichedItem = {
                        ...enrichedItem,
                        type: 'skillgroup',
                        code: code,
                        label: skillGroupData.PREFERREDLABEL?.trim() || 'Unknown Group',
                        description: skillGroupData.DESCRIPTION?.substring(0, 300).trim() || '',
                        altLabels: skillGroupData.ALTLABELS?.trim() || '',
                        category: category,
                        isClickable: true,
                        isSearchable: true,
                        ISLOCALIZED: skillGroupData.ISLOCALIZED || false
                    };
                } else {
                    enrichedItem = {
                        ...enrichedItem,
                        type: 'unknown',
                        label: `Unknown Item (${childId})`,
                        isClickable: false,
                        isSearchable: false
                    };
                }

                skillsMaster[childId] = enrichedItem;
            });

            // Separate skills and skill groups
            const processedSkills = Object.values(skillsMaster).filter(item => item.type === 'skill');
            const processedSkillGroups = Object.values(skillsMaster).filter(item => 
                item.type === 'skillgroup' && item.category !== 'Other'
            );

            // Process occupation-to-skill relationships
            const processedOccupationToSkills = occupationToSkillsParsed.data
                .filter(rel => rel.OCCUPATIONID && rel.SKILLID)
                .map(rel => ({
                    occupationId: rel.OCCUPATIONID.toString().trim(),
                    skillId: rel.SKILLID.toString().trim(),
                    relationType: rel.RELATIONTYPE || 'related',
                    signallingValue: rel.SIGNALLINGVALUE || 0,
                    signallingValueLabel: rel.SIGNALLINGVALUELABEL || ''
                }));

            // Create ID-to-Code mappings
            const occupationIdToCode = {};
            processedOccupations.forEach(occ => {
                if (occ.id) occupationIdToCode[occ.id] = occ.code;
            });

            const skillIdToCode = {};
            processedSkills.forEach(skill => {
                if (skill.id) skillIdToCode[skill.id] = skill.code;
            });

            // Calculate statistics
            const unseenOccs = processedOccupations.filter(o => o.type === 'unseen');
            const seenOccs = processedOccupations.filter(o => o.type === 'seen');
            const unseenGroups = processedGroups.filter(g => g.type === 'unseen');
            const seenGroups = processedGroups.filter(g => g.type === 'seen');

            const stats = {
                totalOccupations: processedOccupations.length,
                totalGroups: processedGroups.length,
                totalSkills: processedSkills.length,
                totalSkillGroups: processedSkillGroups.length,
                totalItems: processedOccupations.length + processedGroups.length + processedSkills.length,
                unseenOccupations: unseenOccs.length,
                unseenGroups: unseenGroups.length,
                unseenTotal: unseenOccs.length + unseenGroups.length,
                seenOccupations: seenOccs.length,
                seenGroups: seenGroups.length,
                seenTotal: seenOccs.length + seenGroups.length,
                occupationSkillRelations: processedOccupationToSkills.length
            };

            // Return the processed data with FIXED hierarchy
            return {
                occupations: processedOccupations,
                groups: processedGroups,
                skills: processedSkills,
                skillGroups: processedSkillGroups,
                occupationToSkills: processedOccupationToSkills,
                stats: stats,
                occupationIdToCode: occupationIdToCode,
                skillIdToCode: skillIdToCode,
                occupationCodeToId: Object.fromEntries(Object.entries(occupationIdToCode).map(([id, code]) => [code, id])),
                skillCodeToId: Object.fromEntries(Object.entries(skillIdToCode).map(([id, code]) => [code, id])),
                skillsMaster: skillsMaster,
                skillHierarchyMap: skillHierarchyMap,
                skillParentMap: skillParentMap,
                // CRITICAL: Include the FIXED occupation hierarchy maps
                hierarchyMap: hierarchyMap,
                parentMap: parentMap
            };
        }

        function markLocalizationDifferences(baseData, localizedData) {
            
            let markedCount = 0;
            
            // Mark new/modified occupations
            localizedData.occupations.forEach(localizedOcc => {
                // Check if item has ISLOCALIZED field set
                if (localizedOcc.ISLOCALIZED === 'TRUE' || localizedOcc.ISLOCALIZED === true) {
                    
                    const baseOcc = baseData.occupations.find(b => b.code === localizedOcc.code);
                    const changes = getLocalizationChanges(baseOcc, localizedOcc);
                    
                    localizedOcc.localizationChanges = changes;
                    localizedOcc.isLocalized = true;
                    markedCount++;
                }
            });
            
            // Mark new/modified groups
            localizedData.groups.forEach(localizedGroup => {
                if (localizedGroup.ISLOCALIZED === 'TRUE' || localizedGroup.ISLOCALIZED === true) {
                    
                    const baseGroup = baseData.groups.find(b => b.code === localizedGroup.code);
                    const changes = getLocalizationChanges(baseGroup, localizedGroup);
                    
                    localizedGroup.localizationChanges = changes;
                    localizedGroup.isLocalized = true;
                    markedCount++;
                }
            });
            
            // Mark new/modified skills  
            localizedData.skills.forEach(localizedSkill => {
                if (localizedSkill.ISLOCALIZED === 'TRUE' || localizedSkill.ISLOCALIZED === true) {
                    
                    const baseSkill = baseData.skills.find(b => b.id === localizedSkill.id);
                    const changes = getLocalizationChanges(baseSkill, localizedSkill);
                    
                    localizedSkill.localizationChanges = changes;
                    localizedSkill.isLocalized = true;
                    markedCount++;
                }
            });
            
        }

        
        // Enhanced tab switching with proper skills tree rendering
        function switchMainTab(tab, element) {
            updateURL({ 
                taxonomy: tab,
                itemId: null,  // Clear item selection when switching tabs
                searchQuery: null // Clear search when switching tabs
            });
            // Update main tab state FIRST
            currentMainTab = tab;
            
            // Update UI - remove active class from all tabs
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            element.classList.add('active');
            
            // Hide/show subtabs and handle tab-specific logic
            document.querySelectorAll('.sub-nav-tabs').forEach(subtab => subtab.classList.remove('active'));
            
            if (tab === 'about') {
                showAboutPanel();
            } else if (tab === 'occupations') {
                // Show occupations subtabs
                document.getElementById('occupations-subtabs').classList.add('active');
                
                // Ensure we're on a valid occupation subtab
                if (!currentSubTab.includes('occupations')) {
                    currentSubTab = 'seen-occupations'; // Default to seen occupations
                }
                
                // Show the explorer panel
                showExplorerPanel();
                
                // Render OCCUPATIONS tree (NOT skills tree)
                renderTaxonomyTreeOptimized().then(() => {
                });
                
                // Show occupations overview
                showOccupationsOverview();
                
            } else if (tab === 'skills') {
                // No subtabs for skills
                currentSubTab = 'skills';
                
                // Show the explorer panel
                showExplorerPanel();
                
                // Render SKILLS tree (NOT occupations tree)
                renderSkillsTreeOptimized().then(() => {
                });
                
                // Show skills overview
                showSkillsOverview();
            }
            
            // Update debug info
            document.getElementById('debugInfo').textContent = `Tab: ${tab} ✅`;
        }

        // Sub-tab switching with proper event handling
        function switchSubTab(tab, element) {
            
            // Update sub tab state
            currentSubTab = tab;
            
            // Update UI - remove active class from all sub tabs
            document.querySelectorAll('.sub-nav-tab').forEach(t => t.classList.remove('active'));
            element.classList.add('active');
            
            // Only render if we're actually on the occupations main tab
            if (currentMainTab === 'occupations') {
                
                showExplorerPanel();
                
                // Render occupations tree for the selected subtab
                renderTaxonomyTreeOptimized().then(() => {
                });
            }
            
            // Update debug info
            document.getElementById('debugInfo').textContent = `SubTab: ${tab} ✅`;
        }

        function showAboutPanel() {
            // Hide the sidebar completely for About tab
            document.querySelector('.sidebar').style.display = 'none';
            
            // Show the explorer layout but expand main panel to full width
            document.querySelector('.explorer-layout').style.display = 'flex';
            document.querySelector('.main-panel').style.width = '100%';
            document.querySelector('.main-panel').style.maxWidth = 'none';
            
            const detailPanel = document.getElementById('detailPanel');
            
            // Use real stats if available, otherwise show placeholders
            const stats = taxonomyData.stats || {};
            const totalOccupations = stats.totalOccupations || '3,067';
            const totalGroups = stats.totalGroups || '635';
            const totalSkills = stats.totalSkills || '13,890';
            const occupationSkillRelations = stats.occupationSkillRelations || '129,300';
            
            detailPanel.innerHTML = `
                <div class="detail-header">
                    <h2 class="detail-title">Inclusive Livelihoods Taxonomy</h2>
                    <div class="detail-description">
                        A comprehensive framework that makes visible and usable the human capital of everyone in an economy. This taxonomy bridges the gap between formal and informal work, recognizing skills and capabilities across all economic activities.
                    </div>
                </div>
                
                <!-- Single row stats with flat highlight styling -->
                <div style="display: flex; justify-content: space-around; gap: 20px; margin-bottom: 40px; flex-wrap: wrap;">
                    <div style="text-align: center; min-width: 200px;">
                        <div style="font-size: 32px; font-weight: var(--font-weight-bold); color: var(--oxford-blue); background: var(--tabiya-green); padding: 8px 16px; border-radius: 6px; margin-bottom: 8px; display: inline-block;">${totalOccupations}</div>
                        <div style="font-size: 14px; font-weight: var(--font-weight-semibold); color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em;">Total Occupations</div>
                    </div>
                    <div style="text-align: center; min-width: 200px;">
                        <div style="font-size: 32px; font-weight: var(--font-weight-bold); color: var(--oxford-blue); background: var(--tabiya-green); padding: 8px 16px; border-radius: 6px; margin-bottom: 8px; display: inline-block;">${totalGroups}</div>
                        <div style="font-size: 14px; font-weight: var(--font-weight-semibold); color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em;">Occupation Groups</div>
                    </div>
                    <div style="text-align: center; min-width: 200px;">
                        <div style="font-size: 32px; font-weight: var(--font-weight-bold); color: var(--oxford-blue); background: var(--tabiya-green); padding: 8px 16px; border-radius: 6px; margin-bottom: 8px; display: inline-block;">${totalSkills}</div>
                        <div style="font-size: 14px; font-weight: var(--font-weight-semibold); color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em;">Skills</div>
                    </div>
                    <div style="text-align: center; min-width: 200px;">
                        <div style="font-size: 32px; font-weight: var(--font-weight-bold); color: var(--oxford-blue); background: var(--tabiya-green); padding: 8px 16px; border-radius: 6px; margin-bottom: 8px; display: inline-block;">${occupationSkillRelations}</div>
                        <div style="font-size: 14px; font-weight: var(--font-weight-semibold); color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em;">Skill Relations</div>
                    </div>
                </div>

                <!-- Redesigned Foundation & Purpose section -->
                <div style="background: transparent; padding: 40px; border-radius: var(--radius-lg); margin: 40px 0;">
                    <div style="margin-bottom: 32px;">
                        <h4 style="color: var(--oxford-blue); margin-bottom: 16px; font-size: 24px; font-weight: var(--font-weight-bold);">What is the Inclusive Livelihoods Taxonomy?</h4>
                        <p style="color: var(--text-secondary); line-height: 1.7; font-size: 16px; margin-bottom: 16px;">
                            The Inclusive Livelihoods Taxonomy is a foundational data framework that recognizes and maps the full spectrum of human economic activities. Unlike traditional occupation classifications that focus primarily on formal employment, this taxonomy includes both seen (formal) and unseen (informal, care, and domestic) work.
                        </p>
                        <p style="color: var(--text-secondary); line-height: 1.7; font-size: 16px;">
                            By making visible the skills and capabilities developed through all forms of work, this taxonomy enables better matching between people and opportunities, more accurate assessment of human capital, and more inclusive economic development.
                        </p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 32px; margin-bottom: 32px;">
                        <div>
                            <h4 style="color: var(--oxford-blue); margin-bottom: 16px; font-size: 20px; font-weight: var(--font-weight-semibold); display: flex; align-items: center; gap: 12px;">
                                <i class="fas fa-eye" style="color: var(--tabiya-dark-green);"></i>Seen Economy
                            </h4>
                            <p style="color: var(--text-secondary); line-height: 1.6; margin-bottom: 12px;">Traditional occupations based on ESCO (European Skills, Competences, Qualifications and Occupations) classifications that are typically measured and recognized in formal economic frameworks.</p>
                            <ul style="color: var(--text-secondary); line-height: 1.6; margin-left: 20px;">
                                <li>Formal employment sectors</li>
                                <li>Professional and technical roles</li>
                                <li>Traditional career pathways</li>
                                <li>Regulated professions</li>
                            </ul>
                        </div>
                        <div>
                            <h4 style="color: var(--oxford-blue); margin-bottom: 16px; font-size: 20px; font-weight: var(--font-weight-semibold); display: flex; align-items: center; gap: 12px;">
                                <i class="fas fa-eye-slash" style="color: var(--tabiya-dark-green);"></i>Unseen Economy
                            </h4>
                            <p style="color: var(--text-secondary); line-height: 1.6; margin-bottom: 12px;">Previously unrecognized activities based on ICATUS (International Classification of Activities for Time Use Statistics) that generate important skills and experiences.</p>
                            <ul style="color: var(--text-secondary); line-height: 1.6; margin-left: 20px;">
                                <li>Unpaid domestic work</li>
                                <li>Care responsibilities</li>
                                <li>Community activities</li>
                                <li>Informal economic activities</li>
                            </ul>
                        </div>
                    </div>

                    <div style="margin-bottom: 32px;">
                        <h4 style="color: var(--oxford-blue); margin-bottom: 16px; font-size: 20px; font-weight: var(--font-weight-semibold); display: flex; align-items: center; gap: 12px;">
                            <i class="fas fa-tools" style="color: var(--tabiya-dark-green);"></i>Skills Integration
                        </h4>
                        <p style="color: var(--text-secondary); line-height: 1.7; font-size: 16px; margin-bottom: 16px;">
                            The taxonomy includes comprehensive mappings between occupations and the skills required to perform them. This enables:
                        </p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px;">
                            <div style="background: var(--white); padding: 20px; border-radius: var(--radius-md); border: 1px solid var(--border-light);">
                                <strong style="color: var(--oxford-blue);">Career Pathways</strong><br>
                                <span style="color: var(--text-secondary); font-size: 14px;">Identify transferable skills across different occupations</span>
                            </div>
                            <div style="background: var(--white); padding: 20px; border-radius: var(--radius-md); border: 1px solid var(--border-light);">
                                <strong style="color: var(--oxford-blue);">Talent Matching</strong><br>
                                <span style="color: var(--text-secondary); font-size: 14px;">Better align people with opportunities based on capabilities</span>
                            </div>
                            <div style="background: var(--white); padding: 20px; border-radius: var(--radius-md); border: 1px solid var(--border-light);">
                                <strong style="color: var(--oxford-blue);">Skills Recognition</strong><br>
                                <span style="color: var(--text-secondary); font-size: 14px;">Validate skills gained through all forms of work</span>
                            </div>
                        </div>
                    </div>

                    <div>
                        <h4 style="color: var(--oxford-blue); margin-bottom: 16px; font-size: 20px; font-weight: var(--font-weight-semibold); display: flex; align-items: center; gap: 12px;">
                            <i class="fas fa-globe" style="color: var(--tabiya-dark-green);"></i>Global Adaptability
                        </h4>
                        <p style="color: var(--text-secondary); line-height: 1.7; font-size: 16px;">
                            Built on international standards, the taxonomy can be adapted to local contexts and labor markets while maintaining global compatibility. This enables cross-border mobility, international development programs, and comparative economic analysis.
                        </p>
                    </div>
                </div>

                <div style="background: var(--oxford-blue); color: white; padding: 32px; border-radius: var(--radius-lg); margin: 32px 0;">
                    <h3 style="margin-bottom: 20px; font-size: 24px; font-weight: var(--font-weight-bold); color: var(--tabiya-green);">Getting Started</h3>
                    <p style="line-height: 1.6; margin-bottom: 20px; opacity: 0.9;">
                        Explore the taxonomy by clicking on the <strong>Occupations</strong> or <strong>Skills</strong> tabs above. Use the search function to quickly find specific items, or browse the hierarchical structure to understand relationships between different elements.
                    </p>
                    <div style="display: flex; gap: 16px; flex-wrap: wrap;">
                        <button onclick="switchMainTab('occupations', document.querySelector('.nav-tab:nth-child(2)'))" style="background: var(--tabiya-green); color: var(--oxford-blue); padding: 12px 20px; border: none; border-radius: var(--radius-md); font-weight: var(--font-weight-semibold); cursor: pointer; transition: all 0.2s ease;">
                            <i class="fas fa-briefcase"></i> Browse Occupations
                        </button>
                        <button onclick="switchMainTab('skills', document.querySelector('.nav-tab:nth-child(3)'))" style="background: transparent; color: white; padding: 12px 20px; border: 2px solid var(--tabiya-green); border-radius: var(--radius-md); font-weight: var(--font-weight-semibold); cursor: pointer; transition: all 0.2s ease;">
                            <i class="fas fa-tools"></i> Explore Skills
                        </button>
                    </div>
                </div>
            `;
        }
        function showOccupationsOverview() {
            const detailPanel = document.getElementById('detailPanel');
            detailPanel.innerHTML = `
                <div class="detail-header">
                    <h2 class="detail-title">Occupations Explorer</h2>
                    <div class="detail-description">
                        Browse and search through comprehensive occupation classifications covering both traditional formal work and previously unrecognized activities. Each occupation is mapped to relevant skills and grouped hierarchically for easy navigation.
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 24px; margin-bottom: 32px;">
                    <div style="background: var(--tabiya-grey); padding: 28px; border-radius: var(--radius-lg); border: 1px solid rgba(0, 255, 145, 0.2);">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                            <i class="fas fa-eye" style="color: var(--tabiya-dark-green); font-size: 24px;"></i>
                            <h3 style="color: var(--oxford-blue); margin: 0; font-size: 20px; font-weight: var(--font-weight-bold);">Seen Economy</h3>
                        </div>
                        <div style="font-size: 18px; color: var(--oxford-blue); background: var(--tabiya-green); padding: 8px 16px; border-radius: 6px; margin-bottom: 8px; display: inline-block">
                            <strong>${taxonomyData.stats?.seenOccupations || 'Loading...'}</strong> occupations in <strong>${taxonomyData.stats?.seenGroups || 'Loading...'}</strong> groups
                        </div>
                        <p style="color: var(--text-secondary); line-height: 1.6; margin-bottom: 16px;">
                            Traditional occupations based on ESCO classifications. These represent formal and informal employment sectors, professional roles, and income-generating activities typically recognized in economic frameworks as "work".
                        </p>
                    </div>
                    
                    <div style="background: var(--tabiya-grey); padding: 28px; border-radius: var(--radius-lg); border: 1px solid rgba(0, 255, 145, 0.2);">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                            <i class="fas fa-eye-slash" style="color: var( --tabiya-dark-green); font-size: 24px;"></i>
                            <h3 style="color: var(--oxford-blue); margin: 0; font-size: 20px; font-weight: var(--font-weight-bold);">Unseen Economy</h3>
                        </div>
                        <div style="font-size: 18px; color: var(--oxford-blue); background: var(--tabiya-green); padding: 8px 16px; border-radius: 6px; margin-bottom: 8px; display: inline-block">
                            <strong>${taxonomyData.stats?.unseenOccupations || 'Loading...'}</strong> occupations in <strong>${taxonomyData.stats?.unseenGroups || 'Loading...'}</strong> groups
                        </div>
                        <p style="color: var(--text-secondary); line-height: 1.6; margin-bottom: 16px;">
                            Previously unrecognized activities based on ICATUS time-use classifications. These include unpaid domestic work, care responsibilities, and community activities that generate valuable skills.
                        </p>
                        
                    </div>
                </div>
                
                <div style="background: var(--oxford-blue); color: white; padding: 32px; border-radius: var(--radius-lg);">
                    <h3 style="margin-bottom: 16px; font-size: 20px; font-weight: var(--font-weight-bold); color: var(--tabiya-green);">How to Explore</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                        <div style="opacity: 0.9;">
                            <div style="font-weight: var(--font-weight-semibold); margin-bottom: 8px;">🔍 Search</div>
                            <div style="font-size: 14px; line-height: 1.5;">Use the search box to quickly find specific occupations by name, code, or description.</div>
                        </div>
                        <div style="opacity: 0.9;">
                            <div style="font-weight: var(--font-weight-semibold); margin-bottom: 8px;">📂 Browse Hierarchy</div>
                            <div style="font-size: 14px; line-height: 1.5;">Navigate through occupation groups to understand the structure and relationships.</div>
                        </div>
                        <div style="opacity: 0.9;">
                            <div style="font-weight: var(--font-weight-semibold); margin-bottom: 8px;">🎯 Select Items</div>
                            <div style="font-size: 14px; line-height: 1.5;">Click on any occupation to view detailed information, required skills, and related items.</div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Updated Skills Overview to match Occupations Overview styling

        function showSkillsOverview() {
            const detailPanel = document.getElementById('detailPanel');
            detailPanel.innerHTML = `
                <div class="detail-header">
                    <h2 class="detail-title">Skills Explorer</h2>
                    <div class="detail-description">
                        Explore the comprehensive skills framework that maps capabilities required across all occupations. Skills are organized hierarchically from broad competency areas to specific technical abilities, with clear relationships to occupations.
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 24px; margin-bottom: 32px;">
                    <div style="background: var(--tabiya-grey); padding: 28px; border-radius: var(--radius-lg); border: 1px solid rgba(0, 255, 145, 0.2); text-align: center;">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 16px;">
                            <i class="fas fa-layer-group" style="color: var(--tabiya-dark-green); font-size: 24px;"></i>
                            <h3 style="color: var(--oxford-blue); margin: 0; font-size: 20px; font-weight: var(--font-weight-bold);">Skill Groups</h3>
                        </div>
                        <div style="font-size: 18px; color: var(--oxford-blue); background: var(--tabiya-green); padding: 8px 16px; border-radius: 6px; margin-bottom: 16px; display: inline-block;">
                            <strong>${taxonomyData.stats?.totalSkillGroups || 'Loading...'}</strong> organized categories
                        </div>
                        <p style="color: var(--text-secondary); line-height: 1.6; margin: 0;">
                            Organized categories including Skills & Competencies, Knowledge domains, Transversal skills, and Language capabilities that provide structure to the skills framework.
                        </p>
                    </div>
                    
                    <div style="background: var(--tabiya-grey); padding: 28px; border-radius: var(--radius-lg); border: 1px solid rgba(0, 255, 145, 0.2); text-align: center;">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 16px;">
                            <i class="fas fa-tools" style="color: var(--tabiya-dark-green); font-size: 24px;"></i>
                            <h3 style="color: var(--oxford-blue); margin: 0; font-size: 20px; font-weight: var(--font-weight-bold);">Individual Skills</h3>
                        </div>
                        <div style="font-size: 18px; color: var(--oxford-blue); background: var(--tabiya-green); padding: 8px 16px; border-radius: 6px; margin-bottom: 16px; display: inline-block;">
                            <strong>${taxonomyData.stats?.totalSkills || 'Loading...'}</strong> specific capabilities
                        </div>
                        <p style="color: var(--text-secondary); line-height: 1.6; margin: 0;">
                            Specific capabilities and competencies that can be developed through various occupations and activities, mapped to show transferable skills across different roles.
                        </p>
                    </div>
                    
                    <div style="background: var(--tabiya-grey); padding: 28px; border-radius: var(--radius-lg); border: 1px solid rgba(0, 255, 145, 0.2); text-align: center;">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 16px;">
                            <i class="fas fa-link" style="color: var(--tabiya-dark-green); font-size: 24px;"></i>
                            <h3 style="color: var(--oxford-blue); margin: 0; font-size: 20px; font-weight: var(--font-weight-bold);">Skill-Occupation Links</h3>
                        </div>
                        <div style="font-size: 18px; color: var(--oxford-blue); background: var(--tabiya-green); padding: 8px 16px; border-radius: 6px; margin-bottom: 16px; display: inline-block;">
                            <strong>${taxonomyData.stats?.occupationSkillRelations || 'Loading...'}</strong> relationships mapped
                        </div>
                        <p style="color: var(--text-secondary); line-height: 1.6; margin: 0;">
                            Comprehensive mappings showing which skills are essential, optional, or related to specific occupations, enabling career pathway analysis and skills gap identification.
                        </p>
                    </div>
                </div>
                
                <div style="background: var(--oxford-blue); color: white; padding: 32px; border-radius: var(--radius-lg);">
                    <h3 style="margin-bottom: 16px; font-size: 20px; font-weight: var(--font-weight-bold); color: var(--tabiya-green);">How to Explore</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                        <div style="opacity: 0.9;">
                            <div style="font-weight: var(--font-weight-semibold); margin-bottom: 8px;">📚 Skill Categories</div>
                            <div style="font-size: 14px; line-height: 1.5;">Expand categories to explore skill groups and individual skills within each domain.</div>
                        </div>
                        <div style="opacity: 0.9;">
                            <div style="font-weight: var(--font-weight-semibold); margin-bottom: 8px;">🔗 View Relationships</div>
                            <div style="font-size: 14px; line-height: 1.5;">Select skill groups to see sub-groups and skills, or select individual skills to see related occupations.</div>
                        </div>
                        <div style="opacity: 0.9;">
                            <div style="font-weight: var(--font-weight-semibold); margin-bottom: 8px;">🎯 Find Applications</div>
                            <div style="font-size: 14px; line-height: 1.5;">Discover which occupations require specific skills and understand career pathways.</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function showExplorerPanel() {
            // Restore sidebar and normal layout for other tabs
            document.querySelector('.sidebar').style.display = 'block';
            document.querySelector('.explorer-layout').style.display = 'flex';
            document.querySelector('.main-panel').style.width = '';
            document.querySelector('.main-panel').style.maxWidth = '';
        }

        // Optimized tree rendering with virtual scrolling
        async function renderTaxonomyTreeOptimized() {
            
            const container = document.getElementById('treeContainer');
            
            // Validate that we have occupation data
            if (!taxonomyData.groups || taxonomyData.groups.length === 0) {
                console.warn('⚠️ No occupation groups data available');
                container.innerHTML = `
                    <div class="loading" style="text-align: center; padding: 40px;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--oxford-blue); margin-bottom: 16px;"></i>
                        <div style="color: var(--text-muted);">Loading occupations data...</div>
                    </div>
                `;
                return;
            }
            
            // Determine economy type from current subtab
            const economyType = currentSubTab.includes('unseen') ? 'unseen' : 'seen';
            
            // Filter groups by economy type
            const filteredGroups = taxonomyData.groups.filter(g => g.type === economyType);
            
            // Get top-level groups (level 1) - these are the root groups
            const topLevelGroups = filteredGroups.filter(g => g.level === 1);
            
            
            if (topLevelGroups.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="text-align: center; padding: 40px;">
                        <i class="fas fa-briefcase" style="font-size: 2rem; color: var(--oxford-blue); margin-bottom: 16px;"></i>
                        <h3>No ${economyType} groups found</h3>
                        <p>No occupation groups available for the ${economyType} economy.</p>
                    </div>
                `;
                return;
            }
            
            // Use traditional rendering for occupation groups
            await renderOccupationGroupsTraditional(container, topLevelGroups, economyType);
            
        }

        async function renderOccupationGroupsTraditional(container, topLevelGroups, economyType) {
            // Sort groups properly
            topLevelGroups.sort((a, b) => {
                const aCode = a.code.toString();
                const bCode = b.code.toString();
                
                // Handle armed forces (0) specially - should be first
                if (aCode === '0') return -1;
                if (bCode === '0') return 1;
                
                // For single digit codes (1, 2, 3, etc.), sort numerically
                if (aCode.length === 1 && bCode.length === 1) {
                    return parseInt(aCode) - parseInt(bCode);
                }
                
                // Mixed lengths - shorter codes first
                if (aCode.length !== bCode.length) {
                    return aCode.length - bCode.length;
                }
                
                // Same length - natural sort
                return aCode.localeCompare(bCode, undefined, { numeric: true });
            });
            
            let html = `<h4 style="margin: 0 0 20px 0; color: var(--oxford-blue);">
                ${economyType === 'seen' ? 'Seen' : 'Unseen'} Economy 
                (${topLevelGroups.length} top-level groups)
            </h4>`;
            
            topLevelGroups.forEach(group => {
                const hasChildren = hasChildGroups(group.code, economyType) || hasChildOccupations(group.code);
                
                // Add localization styling
                const isLocalized = group.isLocalized || (group.ISLOCALIZED === 'TRUE' || group.ISLOCALIZED === true);
                const localizationClass = isLocalized ? 'localized-item' : '';
                const badge = isLocalized ? '<span class="localized-badge">ZA</span>' : '';
                
                html += `
                    <div class="tree-item">
                        <div class="tree-node has-children ${localizationClass}" 
                            onclick="handleTreeNodeClick('${group.code}', 'group', true, event)" 
                            data-code="${group.code}">
                            ${badge}
                            <div class="tree-toggle">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <span class="tree-code">${group.code}</span>
                            <span class="tree-label">${group.label}</span>
                        </div>
                        <div class="tree-children collapsed" id="children-${group.code}">
                            ${renderChildItems(group.code, economyType)}
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // Update the original function name to call the optimized version
        function renderTaxonomyTree() {
            renderTaxonomyTreeOptimized();
        }
        
        
        // Skills tree with proper hierarchy including individual skills
        async function renderSkillsTreeOptimized() {
            console.log(`🔧 Rendering SKILLS tree using unified toggle functions`);
            
            const container = document.getElementById('treeContainer');
            
            if (!taxonomyData.skillGroups || taxonomyData.skillGroups.length === 0) {
                console.warn('⚠️ No skills data available');
                container.innerHTML = `
                    <div class="loading" style="text-align: center; padding: 40px;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--oxford-blue); margin-bottom: 16px;"></i>
                        <div style="color: var(--text-muted);">Loading skills data...</div>
                    </div>
                `;
                return;
            }
            
            // Group skill groups by category
            const skillGroupsByCategory = {};
            taxonomyData.skillGroups.forEach(group => {
                const category = group.category;
                if (!skillGroupsByCategory[category]) {
                    skillGroupsByCategory[category] = [];
                }
                skillGroupsByCategory[category].push(group);
            });

            let skillsHtml = `<h4 style="margin: 0 0 20px 0; color: var(--oxford-blue);">Skills Hierarchy (${taxonomyData.skillGroups.length} groups)</h4>`;
            
            const categoryOrder = [
                'Skills and competencies',
                'Knowledge',
                'Transversal skills', 
                'Language'
            ];
            
            let hasContent = false;
            
            for (const category of categoryOrder) {
                if (skillGroupsByCategory[category]) {
                    const groups = skillGroupsByCategory[category];
                    console.log(`📊 Rendering skills category ${category} with ${groups.length} groups`);
                    
                    // Use the same pattern as occupation groups - just use category as the "code"
                    const categoryCode = category.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
                    
                    skillsHtml += `
                        <div class="tree-item">
                            <div class="tree-node has-children" onclick="handleTreeNodeClick('${categoryCode}', 'category', true, event)" data-code="${categoryCode}">
                                <div class="tree-toggle">
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <span class="tree-label">${category} (${groups.length})</span>
                            </div>
                            <div class="tree-children collapsed" id="children-${categoryCode}">
                                ${await renderSkillCategoryContentOptimized(groups, category)}
                            </div>
                        </div>
                    `;
                    hasContent = true;
                }
            }
            
            if (!hasContent) {
                skillsHtml = `
                    <div class="empty-state" style="text-align: center; padding: 40px;">
                        <i class="fas fa-tools" style="font-size: 2rem; color: var(--oxford-blue); margin-bottom: 16px;"></i>
                        <h3>No Skills Data</h3>
                        <p>Skills data is not available or failed to load.</p>
                    </div>
                `;
            }
            
            container.innerHTML = skillsHtml;
            console.log(`✅ Skills tree rendered successfully using unified toggle system`);
        }
        
        // Update original function to call optimized version
        function renderSkillsTree() {
            renderSkillsTreeOptimized();
        }




        function renderTreeNodeWithLocalization(item, type, code) {
            const isLocalized = isLocalizedContent(item);
            const localizationClass = isLocalized ? 'localized-item' : '';
            const badge = isLocalized ? '<span class="localized-badge">Local</span>' : '';
            
            // Determine if it's a new addition
            const isNewAddition = item.localizationChanges?.isNew;
            const additionClass = isNewAddition ? 'localized-addition' : '';
            
            return `
                <div class="tree-node ${localizationClass} ${additionClass}" onclick="selectItem('${code}', '${type}', event)" data-code="${code}">
                    <div class="tree-toggle"></div>
                    ${item.code ? `<span class="tree-code">${item.code}</span>` : ''}
                    <span class="tree-label">${item.label}${badge}</span>
                </div>
            `;
        }

        function renderCompleteSkillHierarchy(groups, category) {
            let html = '';
            
            // Find top-level groups using Skills Master
            const topLevelGroups = groups.filter(group => {
                if (!group.parentId) return true;
                
                const parent = taxonomyData.skillsMaster[group.parentId];
                return !parent || parent.category !== category;
            });
            
            // Sort top-level groups
            topLevelGroups.sort((a, b) => {
                return a.code.localeCompare(b.code, undefined, { numeric: true });
            });
            
            topLevelGroups.forEach(group => {
                html += renderSkillGroupWithChildren(group.id);
            });
            
            return html;
        }

        // Enhanced skill rendering with proper on-demand loading - FIXED
        function renderSkillGroupWithChildren(groupId) {
            console.log(`🔧 Rendering children for skill group: ${groupId}`);
            
            const group = taxonomyData.skillsMaster[groupId];
            if (!group || group.type !== 'skillgroup') {
                console.warn(`⚠️ No skill group found for ID: ${groupId}`);
                return '';
            }
            
            // Get IMMEDIATE children only
            const childrenIds = group.childrenIds || [];
            console.log(`🔧 Found ${childrenIds.length} children for ${group.code} (${group.label})`);
            
            if (childrenIds.length === 0) {
                return '<div style="padding: 16px; color: var(--text-muted); font-style: italic;">No sub-items found</div>';
            }
            
            const children = childrenIds.map(id => taxonomyData.skillsMaster[id]).filter(Boolean);
            
            // Separate skill groups and skills
            const childGroups = children.filter(child => child.type === 'skillgroup');
            const childSkills = children.filter(child => child.type === 'skill');
            
            console.log(`🔧 ${childGroups.length} child groups, ${childSkills.length} child skills`);
            
            let html = '';
            
            // Render child groups first (these can be expanded further)
            childGroups.sort((a, b) => a.code.localeCompare(b.code, undefined, { numeric: true }));
            childGroups.forEach(childGroup => {
                const hasGrandchildren = childGroup.childrenIds && childGroup.childrenIds.length > 0;
                
                html += `
                    <div class="tree-item">
                        <div class="tree-node ${hasGrandchildren ? 'has-children' : ''}" 
                            onclick="handleTreeNodeClick('${childGroup.id}', 'skillgroup', ${hasGrandchildren}, event)" 
                            data-code="${childGroup.id}"
                            style="font-family: var(--font-family-sans) !important; text-transform: none !important;">
                            ${hasGrandchildren ? 
                                `<div class="tree-toggle"><i class="fas fa-chevron-right"></i></div>` : 
                                '<div class="tree-toggle"></div>'
                            }
                            <span class="tree-code" style="font-family: var(--font-family-sans) !important; text-transform: none !important;">${childGroup.code}</span>
                            <span class="tree-label" style="font-family: var(--font-family-sans) !important; text-transform: none !important;">${childGroup.label}</span>
                        </div>
                        ${hasGrandchildren ? `<div class="tree-children collapsed" id="children-${childGroup.id}"></div>` : ''}
                    </div>
                `;
            });
            
            // Render individual skills (these are leaf nodes)
            childSkills.sort((a, b) => a.label.localeCompare(b.label));
            childSkills.forEach(skill => {
                const hasSkillChildren = skill.childrenIds && skill.childrenIds.length > 0;
                const skillClasses = hasSkillChildren ? 'skill-item expandable has-children' : 'skill-item';
                
                html += `
                    <div class="tree-item">
                        <div class="tree-node ${skillClasses}" 
                            onclick="handleTreeNodeClick('${skill.id}', 'skill', ${hasSkillChildren}, event)" 
                            data-code="${skill.id}"
                            style="font-family: var(--font-family-sans) !important; text-transform: none !important;">
                            ${hasSkillChildren ? 
                                `<div class="tree-toggle"><i class="fas fa-chevron-right"></i></div>` : 
                                '<div class="tree-toggle"></div>'
                            }
                            <span class="tree-label" style="font-family: var(--font-family-sans) !important; text-transform: none !important;">${skill.label}</span>
                        </div>
                        ${hasSkillChildren ? `<div class="tree-children collapsed" id="children-${skill.id}"></div>` : ''}
                    </div>
                `;
            });
            
            console.log(`🔧 Generated HTML length: ${html.length}`);
            return html;
        }


        
        // Handle individual skills with potential children (skill-to-skill nesting)
        function renderIndividualSkillWithChildren(skillId) {
            const skill = taxonomyData.skillsMaster[skillId];
            if (!skill || skill.type !== 'skill') return '';
            
            // Check if this individual skill has children (other skills)
            const childrenIds = skill.childrenIds || [];
            const childSkills = childrenIds
                .map(id => taxonomyData.skillsMaster[id])
                .filter(child => child && child.type === 'skill');
            
            const hasChildren = childSkills.length > 0;
            const skillClasses = hasChildren ? 'skill-item expandable has-children' : 'skill-item';
            
            let html = `
                <div class="tree-item">
                    <div class="tree-node ${skillClasses}" 
                        onclick="handleTreeNodeClick('${skill.id}', 'skill', ${hasChildren}, event)" 
                        data-code="${skill.id}"
                        style="font-family: var(--font-family-sans) !important; text-transform: none !important;">
                        ${hasChildren ? 
                            `<div class="tree-toggle"><i class="fas fa-chevron-right"></i></div>` : 
                            '<div class="tree-toggle"></div>'
                        }
                        <span class="tree-label" style="font-family: var(--font-family-sans) !important; text-transform: none !important;">${skill.label}</span>
                    </div>
            `;
            
            // Render nested skills if they exist
            if (hasChildren) {
                html += `<div class="tree-children collapsed" id="children-${skill.id}">`;
                
                childSkills.sort((a, b) => a.label.localeCompare(b.label));
                childSkills.forEach(childSkill => {
                    html += renderIndividualSkillWithChildren(childSkill.id);
                });
                
                html += '</div>';
            }
            
            html += '</div>';
            
            return html;
        }
        // Group tree rendering with proper sorting
        function renderGroupTree(groups, economyType) {
            let html = '';
            
            // Sort groups to ensure proper nesting order
            groups.sort((a, b) => {
                const aCode = a.code.toString();
                const bCode = b.code.toString();
                
                // Handle armed forces (0) specially - should be first
                if (aCode === '0') return -1;
                if (bCode === '0') return 1;
                
                // For single digit codes (1, 2, 3, etc.), sort numerically
                if (aCode.length === 1 && bCode.length === 1) {
                    return parseInt(aCode) - parseInt(bCode);
                }
                
                // Mixed lengths - shorter codes first
                if (aCode.length !== bCode.length) {
                    return aCode.length - bCode.length;
                }
                
                // Same length - natural sort
                return aCode.localeCompare(bCode, undefined, { numeric: true });
            });
            
            groups.forEach(group => {
                const hasChildren = hasChildGroups(group.code, economyType) || hasChildOccupations(group.code);
                
                html += `
                    <div class="tree-item">
                        <div class="tree-node has-children" onclick="selectItem('${group.code}', 'group', event)" data-code="${group.code}">
                            <div class="tree-toggle" onclick="toggleGroupNode('${group.code}', event)">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <span class="tree-code">${group.code}</span>
                            <span class="tree-label">${group.label}</span>
                        </div>
                        <div class="tree-children collapsed" id="children-${group.code}">
                            ${renderChildItems(group.code, economyType)}
                        </div>
                    </div>
                `;
            });
            
            return html;
        }

        // Child items rendering with proper sorting
            // Updated child items rendering with full-box toggle
        function renderChildItems(parentCode, economyType) {
            let html = '';
            
            // Get child groups using PROPER parent relationships
            const childGroups = taxonomyData.groups.filter(g => g.parent === parentCode && g.type === economyType);
            
            // Sort child groups by code
            childGroups.sort((a, b) => {
                const aCode = a.code.toString();
                const bCode = b.code.toString();
                return aCode.localeCompare(bCode, undefined, { numeric: true });
            });
            
            
            childGroups.forEach(group => {
                const hasChildren = hasChildGroups(group.code, economyType) || hasChildOccupations(group.code);
                const toggle = hasChildren ? 
                    `<div class="tree-toggle"><i class="fas fa-chevron-right"></i></div>` : 
                    '<div class="tree-toggle"></div>';
                
                const isLocalized = group.isLocalized || (group.ISLOCALIZED === 'TRUE' || group.ISLOCALIZED === true);
                const localizationClass = isLocalized ? 'localized-item' : '';
                const badge = isLocalized ? '<span class="localized-badge">ZA</span>' : '';
                
                html += `
                    <div class="tree-item">
                        <div class="tree-node ${hasChildren ? 'has-children' : ''} ${localizationClass}" 
                            onclick="handleTreeNodeClick('${group.code}', 'group', ${hasChildren}, event)" 
                            data-code="${group.code}"
                            style="font-family: var(--font-family-sans) !important; text-transform: none !important;">
                            ${badge}
                            ${toggle}
                            <span class="tree-code" style="font-family: var(--font-family-sans) !important; text-transform: none !important;">${group.code}</span>
                            <span class="tree-label" style="font-family: var(--font-family-sans) !important; text-transform: none !important;">${group.label}</span>
                        </div>
                        ${hasChildren ? `<div class="tree-children collapsed" id="children-${group.code}">
                            ${renderChildItems(group.code, economyType)}
                        </div>` : ''}
                    </div>
                `;
            });            
            
            // Get child occupations using proper groupCode
            const childOccupations = taxonomyData.occupations.filter(o => o.groupCode === parentCode && o.type === economyType);
            
            // Sort child occupations by code
            childOccupations.sort((a, b) => {
                const aCode = a.code.toString();
                const bCode = b.code.toString();
                return aCode.localeCompare(bCode, undefined, { numeric: true });
            });
            
            
            childOccupations.forEach(occ => {
                // Add localization styling
                const isLocalized = occ.isLocalized || (occ.ISLOCALIZED === 'TRUE' || occ.ISLOCALIZED === true);
                const localizationClass = isLocalized ? 'localized-item' : '';
                const badge = isLocalized ? '<span class="localized-badge">ZA</span>' : '';
                
                html += `
                    <div class="tree-item">
                        <div class="tree-node ${localizationClass}" 
                            onclick="handleTreeNodeClick('${occ.code}', 'occupation', false, event)" 
                            data-code="${occ.code}">
                            ${badge}
                            <div class="tree-toggle"></div>
                            <span class="tree-code">${occ.code}</span>
                            <span class="tree-label">${occ.label}</span>
                        </div>
                    </div>
                `;
            });

            // Apply font fixes after rendering
            setTimeout(applyFontFixes, 50);

            return html;
        }



        function hasChildGroups(code, economyType) {
            return taxonomyData.groups.some(g => g.parent === code && g.type === economyType);
        }

        function hasChildOccupations(code) {
            return taxonomyData.occupations.some(o => o.groupCode === code);
        }

        // Toggle functions with proper event handling

        function toggleGroupNode(code, event) {
            if (event) event.stopPropagation();
            toggleNodeGeneric(code, event);
        }

        function toggleNodeGeneric(code, event) {
            const childrenEl = document.getElementById(`children-${code}`);
            const toggleIcon = event ? (event.target.querySelector('i') || event.target) : null;
            
            if (childrenEl && childrenEl.classList.contains('collapsed')) {
                // Check if children need to be loaded on demand (empty or has placeholder comment)
                const needsLoading = !childrenEl.innerHTML.trim() || 
                                childrenEl.innerHTML.includes('<!-- Children loaded on demand -->') || 
                                childrenEl.innerHTML.includes('<!-- Grandchildren loaded on demand -->') || 
                                childrenEl.innerHTML.includes('<!-- Skill children loaded on demand -->');
                
                if (needsLoading) {
                    // Check if this is a skill group that needs dynamic loading
                    const skillGroup = taxonomyData.skillsMaster[code];
                    if (skillGroup && skillGroup.type === 'skillgroup') {
                        console.log(`🔧 Loading children for skill group: ${code} (${skillGroup.label})`);
                        childrenEl.innerHTML = renderSkillGroupWithChildren(code);
                    } else {
                        // For occupation groups, use existing logic
                        console.log(`🔧 Loading children for occupation group: ${code}`);
                        const economyType = currentSubTab.includes('unseen') ? 'unseen' : 'seen';
                        childrenEl.innerHTML = renderChildItems(code, economyType);
                    }
                }
                
                childrenEl.classList.remove('collapsed');
                if (toggleIcon) toggleIcon.className = 'fas fa-chevron-down';
            } else if (childrenEl) {
                childrenEl.classList.add('collapsed');
                if (toggleIcon) toggleIcon.className = 'fas fa-chevron-right';
            }
        }

        // Enhanced selectItem function with CROSS-TAXONOMY NAVIGATION
        function selectItem(code, type, event) {
            // Find MongoDB ID from code
            let itemId = null;
            
            if (type === 'occupation') {
                const item = taxonomyData.occupations.find(o => o.code === code);
                itemId = item ? item.id : null;
            } else if (type === 'group') {
                const item = taxonomyData.groups.find(g => g.code === code);
                itemId = item ? item.id : null;
            } else if (type === 'skill' || type === 'skillgroup') {
                itemId = code; // For skills, code is already the ID
            }
            
            if (itemId) {
                updateURL({ itemId: itemId });
            }
            if (event) event.stopPropagation();
                        
            try {
                // ENHANCEMENT #5: Cross-Taxonomy Navigation Logic
                let shouldSwitchPanel = false;
                let targetMainTab = currentMainTab;
                
                // Determine if we need to switch main tabs based on item type
                if (type === 'skill' || type === 'skillgroup') {
                    if (currentMainTab !== 'skills') {
                        targetMainTab = 'skills';
                        shouldSwitchPanel = true;
                    }
                } else if (type === 'occupation' || type === 'group') {
                    if (currentMainTab !== 'occupations') {
                        targetMainTab = 'occupations';
                        shouldSwitchPanel = true;
                    }
                }
                
                // Perform the panel switch if needed
                if (shouldSwitchPanel) {
                    // Update main tab state
                    currentMainTab = targetMainTab;
                    
                    // Update UI tabs
                    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                    if (targetMainTab === 'skills') {
                        document.querySelector('.nav-tab:nth-child(3)').classList.add('active'); // Skills tab
                    } else if (targetMainTab === 'occupations') {
                        document.querySelector('.nav-tab:nth-child(2)').classList.add('active'); // Occupations tab
                    }
                    
                    // Show/hide appropriate sub-tabs
                    document.querySelectorAll('.sub-nav-tabs').forEach(subtab => subtab.classList.remove('active'));
                    if (targetMainTab === 'occupations') {
                        document.getElementById('occupations-subtabs').classList.add('active');
                        
                        // Set appropriate sub-tab for occupation type
                        if (type === 'occupation' || type === 'group') {
                            const item = (type === 'occupation') ? 
                                taxonomyData.occupations.find(o => o.code === code || o.id === code) :
                                taxonomyData.groups.find(g => g.code === code);
                            
                            if (item && item.type === 'unseen') {
                                currentSubTab = 'unseen-occupations';
                                document.querySelectorAll('.sub-nav-tab').forEach(t => t.classList.remove('active'));
                                document.querySelector('.sub-nav-tab:nth-child(2)').classList.add('active');
                            } else {
                                currentSubTab = 'seen-occupations';
                                document.querySelectorAll('.sub-nav-tab').forEach(t => t.classList.remove('active'));
                                document.querySelector('.sub-nav-tab:nth-child(1)').classList.add('active');
                            }
                        }
                    }
                    
                    // Re-render the appropriate tree
                    setTimeout(async () => {
                        if (targetMainTab === 'skills') {
                            await renderSkillsTreeOptimized();
                        } else if (targetMainTab === 'occupations') {
                            await renderTaxonomyTreeOptimized();
                        }
                        
                        // After re-rendering, find and highlight the selected item
                        setTimeout(() => {
                            const nodeElement = document.querySelector(`[data-code="${code}"]`);
                            if (nodeElement) {
                                nodeElement.classList.add('selected');
                                
                                // Expand parent nodes if needed (no smooth scrolling)
                                expandAndScrollToItem(nodeElement, code, type);
                                
                            } else {
                                console.warn(`⚠️ Could not find ${type} ${code} in new tree after cross-navigation`);
                            }
                        }, 100);
                    }, 50);
                }
                
                // Clear previous selection
                document.querySelectorAll('.tree-node').forEach(node => node.classList.remove('selected'));
                
                // Find and highlight the clicked element (if not switching panels)
                if (!shouldSwitchPanel) {
                    const nodeElement = document.querySelector(`[data-code="${code}"]`);
                    if (nodeElement) {
                        nodeElement.classList.add('selected');
                    } else {
                        console.warn(`⚠️ Could not find node element for code: ${code}`);
                    }
                }
                
                // Find the item in the data
                let item = null;
                
                if (type === 'group') {
                    item = taxonomyData.groups.find(g => g.code === code);
                } else if (type === 'skill' || type === 'skillgroup') {
                    // Use Skills Master for all skill lookups
                    item = taxonomyData.skillsMaster[code];
                    if (item) {
                        // Preserve the correct type passed in
                        type = item.type === 'skillgroup' ? 'skillgroup' : 'skill';
                    }
                } else if (type === 'occupation') {
                    item = taxonomyData.occupations.find(o => o.code === code || o.id === code);
                }
                
                if (item) {
                    selectedItem = { ...item, type };
                    renderDetailPanel(selectedItem);
                    
                    // Update debug info
                    document.getElementById('debugInfo').textContent = `Selected: ${type} ${code} ${shouldSwitchPanel ? '(Cross-nav)' : ''} ✅`;
                } else {
                    console.error(`❌ Could not find item with code: ${code}, type: ${type}`);
                    
                    // Show error in detail panel
                    const panel = document.getElementById('detailPanel');
                    panel.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-exclamation-triangle"></i>
                            <h3>Item not found</h3>
                            <p>Could not find ${type} with code "${code}". This might be a data loading issue.</p>
                        </div>
                    `;
                    
                    // Update debug info
                    document.getElementById('debugInfo').textContent = `Error: ${type} ${code} ❌`;
                }
                
            } catch (error) {
                console.error(`❌ Error in selectItem:`, error);
                
                // Update debug info
                document.getElementById('debugInfo').textContent = `Error: ${error.message} ❌`;
            }
        }
        
        // New function to select item by MongoDB ID
        function selectItemById(mongoId) {
            // Find item by MongoDB ID
            let item = null;
            let type = null;
            
            // Check occupations
            item = taxonomyData.occupations.find(o => o.id === mongoId);
            if (item) {
                type = 'occupation';
                return selectItem(item.code, type);
            }
            
            // Check groups  
            item = taxonomyData.groups.find(g => g.id === mongoId);
            if (item) {
                type = 'group';
                return selectItem(item.code, type);
            }
            
            // Check skills master
            item = taxonomyData.skillsMaster[mongoId];
            if (item) {
                type = item.type === 'skillgroup' ? 'skillgroup' : 'skill';
                return selectItem(mongoId, type);
            }
            
            console.warn(`Item not found for ID: ${mongoId}`);
        }
        // Helper function to expand parent nodes and scroll item into view
        function expandAndScrollToItem(nodeElement, code, type) {
            try {
                // Find all parent containers that might need expanding
                let currentElement = nodeElement.parentElement;
                const containersToExpand = [];
                
                while (currentElement && currentElement !== document.body) {
                    if (currentElement.classList.contains('tree-children') && 
                        currentElement.classList.contains('collapsed')) {
                        containersToExpand.push(currentElement);
                    }
                    currentElement = currentElement.parentElement;
                }
                
                // Expand parent containers from top to bottom
                containersToExpand.reverse().forEach(container => {
                    container.classList.remove('collapsed');
                    
                    // Find and update the toggle icon
                    const toggleElement = container.previousElementSibling?.querySelector('.tree-toggle i');
                    if (toggleElement) {
                        toggleElement.className = 'fas fa-chevron-down';
                    }
                });
                
                // For skills, also expand category containers
                if (type === 'skill' || type === 'skillgroup') {
                    expandSkillCategoryPath(code, type);
                }
                
                
            } catch (error) {
                console.warn(`⚠️ Error expanding path for ${code}:`, error);
            }
        }

        // Helper function specifically for skills tree expansion
        function expandSkillCategoryPath(code, type) {
            try {
                let item = taxonomyData.skillsMaster[code];
                if (!item) return;
                
                // Find the category this skill belongs to
                let categoryElement = null;
                
                // Walk up the hierarchy to find the top-level category
                let currentId = item.id;
                let safetyCount = 0;
                
                while (currentId && safetyCount < 20) {
                    const currentItem = taxonomyData.skillsMaster[currentId];
                    if (currentItem && currentItem.category) {
                        // Found the category, now expand it
                        categoryElement = document.getElementById(`children-category-${currentItem.category}`);
                        if (categoryElement && categoryElement.classList.contains('collapsed')) {
                            categoryElement.classList.remove('collapsed');
                            
                            // Update category toggle icon
                            const categoryToggle = document.querySelector(`[data-category="${currentItem.category}"] .tree-toggle i`);
                            if (categoryToggle) {
                                categoryToggle.className = 'fas fa-chevron-down';
                            }
                            
                        }
                        break;
                    }
                    currentId = currentItem?.parentId;
                    safetyCount++;
                }
                
                // Also expand any skill group containers in the path
                currentId = item.id;
                safetyCount = 0;
                
                while (currentId && safetyCount < 20) {
                    const skillContainer = document.getElementById(`children-skill-${currentId}`);
                    if (skillContainer && skillContainer.classList.contains('collapsed')) {
                        skillContainer.classList.remove('collapsed');
                        
                        // Update skill group toggle icon
                        const skillToggle = document.querySelector(`[data-code="${currentId}"] .tree-toggle i`);
                        if (skillToggle) {
                            skillToggle.className = 'fas fa-chevron-down';
                        }
                    }
                    
                    const currentItem = taxonomyData.skillsMaster[currentId];
                    currentId = currentItem?.parentId;
                    safetyCount++;
                }
                
            } catch (error) {
                console.warn(`⚠️ Error expanding skill category path:`, error);
            }
        }

        // Enhanced detail panel with breadcrumb navigation and proper code display
        function renderDetailPanel(item) {
            const panel = document.getElementById('detailPanel');
            
            
            try {
                // Generate breadcrumb navigation
                const breadcrumb = generateBreadcrumb(item);
                
                // Show code only for occupations and skill groups, not individual skills
                const codeSection = (item.type === 'skill') ? '' : `<div class="detail-code">${item.code || item.id}</div>`;
                
                // Alternative Labels Section
                const altLabelsSection = item.altLabels ? (() => {
                    let labelsToShow = item.altLabels;
                    
                    // For localized items, exclude the added labels from the alt labels display
                    if (currentLocalization && item.localizationChanges && item.localizationChanges.altLabelsAdded) {
                        const addedLabels = item.localizationChanges.altLabelsAdded.split(/[,\n]/).map(l => l.trim().toLowerCase());
                        const allLabels = item.altLabels.split(/[,\n]/).map(l => l.trim());
                        
                        // Filter out the added labels, keeping only base labels
                        const baseLabels = allLabels.filter(label => 
                            !addedLabels.includes(label.toLowerCase())
                        );
                        
                        labelsToShow = baseLabels.join(', ');
                    }
                    
                    // Only show the section if there are base labels to display
                    if (!labelsToShow.trim()) {
                        return '';
                    }
                    
                    return `
                        <div class="alt-labels-section">
                            <h4 style="color: var(--oxford-blue); margin-bottom: 12px; font-size: 18px; font-weight: var(--font-weight-bold);">Alternative Labels</h4>
                            <div class="alt-labels-list">
                                ${labelsToShow.split('\n').filter(label => label.trim()).map(label => label.trim()).join(', ')}
                            </div>
                        </div>
                    `;
                })() : '';

                // SA Localization info (MOVED TO BE AFTER ALT LABELS)
                const localizationInfo = renderLocalizationInfo(item);

                // Skills section for occupations
                const skillsSection = (item.type === 'occupation') ? renderOccupationSkills(item) : '';
                
                // Related occupations section for skills
                const relatedSection = (item.type === 'skill' || item.type === 'skillgroup') ? 
                    renderSkillOccupations(item) : renderRelatedItems(item);
                
                panel.innerHTML = `
                    ${breadcrumb}
                    <div class="detail-header">
                        ${codeSection}
                        <h2 class="detail-title">${item.label}</h2>
                        <div class="detail-description">${item.description || 'No description available.'}</div>
                    </div>
                    
                    ${altLabelsSection}
                    ${localizationInfo}
                    ${skillsSection}
                    ${relatedSection}
                `;
                
                
            } catch (error) {
                console.error(`❌ Error rendering detail panel:`, error);
                
                panel.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-exclamation-triangle"></i>
                        <h3>Display Error</h3>
                        <p>Could not display details for this item: ${error.message}</p>
                    </div>
                `;
            }
        }

        // Enhanced tree node click handler for full-box toggle functionality
        function handleTreeNodeClick(code, type, hasChildren, event) {
            if (event) event.stopPropagation();
            
            console.log(`🖱️ Full-box click: ${code}, type: ${type}, hasChildren: ${hasChildren}`);
            
            if (hasChildren) {
                // For expandable items: toggle expansion on any click using UNIFIED function
                toggleNodeGeneric(code, event);
                
                // Also select the item (but don't trigger cross-navigation for groups or categories)
                if (type !== 'group' && type !== 'category') {
                    selectItem(code, type, event);
                } else {
                    // For groups and categories, just update selection styling without full selectItem
                    document.querySelectorAll('.tree-node').forEach(node => node.classList.remove('selected'));
                    const nodeElement = document.querySelector(`[data-code="${code}"]`);
                    if (nodeElement) {
                        nodeElement.classList.add('selected');
                    }
                    
                    // Show details for skill groups (but not for categories)
                    if (type === 'group') {
                        const group = taxonomyData.groups.find(g => g.code === code);
                        if (group) {
                            renderDetailPanel({ ...group, type: 'group' });
                        }
                    } else if (type === 'skillgroup') {
                        // Show details for skill groups too
                        const skillGroup = taxonomyData.skillsMaster[code];
                        if (skillGroup) {
                            renderDetailPanel({ ...skillGroup, type: 'skillgroup' });
                        }
                    }
                }
            } else {
                // For non-expandable items: just select
                selectItem(code, type, event);
            }
            
            // Visual feedback
            const nodeElement = event.currentTarget;
            if (nodeElement) {
                nodeElement.style.transition = 'transform 0.1s ease';
                nodeElement.style.transform = 'scale(0.98)';
                setTimeout(() => {
                    nodeElement.style.transform = '';
                }, 100);
            }
        }
        
        
        function renderLocalizationInfo(item) {
            if (!currentLocalization || !isLocalizedContent(item)) {
                return '';
            }
            
            const changes = item.localizationChanges || {};
            let infoHtml = '';
            
            if (changes.isNew) {
                infoHtml = `
                    <div class="localization-info" style="background: var(--tabiya-light-green); padding: 20px; border-radius: var(--radius-lg); margin: 24px 0; border-left: 4px solid var(--tabiya-green);">
                        <h5 style="color: var(--oxford-blue); margin-bottom: 12px; font-weight: var(--font-weight-bold);">🇿🇦 South African Addition</h5>
                        <p style="margin: 0; color: var(--text-secondary); line-height: 1.6;">This ${item.type} was added specifically for the South African context.</p>
                    </div>
                `;
            } else if (changes.altLabelsAdded) {
                infoHtml = `
                    <div class="localization-info" style="background: var(--tabiya-light-green); padding: 20px; border-radius: var(--radius-lg); margin: 24px 0; border-left: 4px solid var(--tabiya-green);">
                        <h5 style="color: var(--oxford-blue); margin-bottom: 12px; font-weight: var(--font-weight-bold);">🇿🇦 South African Terms Added</h5>
                        <p style="margin: 0; color: var(--text-secondary); line-height: 1.6;">Additional local terms: <span style="color: var(--oxford-blue); font-weight: var(--font-weight-semibold);">${changes.altLabelsAdded}</span></p>
                    </div>
                `;
            }
            
            return infoHtml;
        }

        // Generate breadcrumb navigation with FIXED hierarchy traversal
        function generateBreadcrumb(item) {
            let breadcrumbItems = [];
            
            if (item.type === 'occupation') {
                // Build occupation breadcrumb: Economy > Major Group > Sub-major Group > Minor Group > Unit Group > Occupation
                const economyType = item.type === 'unseen' ? 'Unseen Economy' : 'Seen Economy';
                breadcrumbItems.push({ 
                    label: economyType, 
                    action: `switchSubTab('${item.type}-occupations', document.querySelector('.sub-nav-tab.active'))` 
                });
                
                // FIXED: Trace complete hierarchy path using parentMap
                const hierarchyPath = [];
                let currentGroupCode = item.groupCode;
                let safetyCount = 0;
                
                // Walk up the hierarchy to build complete path
                while (currentGroupCode && safetyCount < 10) {
                    const group = taxonomyData.groups.find(g => g.code === currentGroupCode);
                    if (group) {
                        hierarchyPath.unshift(group); // Add to beginning
                        currentGroupCode = group.parent; // Move to parent using FIXED parent relationship
                    } else {
                        break;
                    }
                    safetyCount++;
                }
                
                // Add each level in the complete hierarchy path
                hierarchyPath.forEach(group => {
                    breadcrumbItems.push({ 
                        label: `${group.code} - ${group.label}`, 
                        action: `selectItem('${group.code}', 'group')` 
                    });
                });
                
                breadcrumbItems.push({ label: item.label, action: null }); // Current item
                
            } else if (item.type === 'group') {
                // Build group breadcrumb with complete hierarchy
                const economyType = item.type === 'unseen' ? 'Unseen Economy' : 'Seen Economy';
                breadcrumbItems.push({ 
                    label: economyType, 
                    action: `switchSubTab('${item.type}-occupations', document.querySelector('.sub-nav-tab.active'))` 
                });
                
                // FIXED: Use actual parent relationships from CSV
                const hierarchyPath = [];
                let currentGroup = item;
                let safetyCount = 0;
                
                // Build complete path to root
                while (currentGroup && safetyCount < 10) {
                    hierarchyPath.unshift(currentGroup);
                    if (currentGroup.parent) {
                        currentGroup = taxonomyData.groups.find(g => g.code === currentGroup.parent);
                    } else {
                        break;
                    }
                    safetyCount++;
                }
                
                // Add all but the current item to breadcrumb
                for (let i = 0; i < hierarchyPath.length - 1; i++) {
                    const pathGroup = hierarchyPath[i];
                    breadcrumbItems.push({ 
                        label: `${pathGroup.code} - ${pathGroup.label}`, 
                        action: `selectItem('${pathGroup.code}', 'group')` 
                    });
                }
                
                breadcrumbItems.push({ label: item.label, action: null }); // Current item
                
            } else if (item.type === 'skillgroup') {
                // Skills breadcrumb (already working correctly)
                breadcrumbItems.push({ 
                    label: 'Skills', 
                    action: `switchMainTab('skills', document.querySelector('.nav-tab:nth-child(3)'))` 
                });
                
                // Trace complete hierarchy for skill groups
                const hierarchyPath = [];
                let currentId = item.id;
                let safetyCount = 0;
                
                while (currentId && safetyCount < 20) {
                    const currentItem = taxonomyData.skillsMaster[currentId];
                    if (currentItem) {
                        hierarchyPath.unshift(currentItem);
                    }
                    currentId = currentItem?.parentId;
                    safetyCount++;
                }
                
                // Add category and hierarchy path to breadcrumb
                if (hierarchyPath.length > 0) {
                    const topLevelGroup = hierarchyPath[0];
                    if (topLevelGroup.category) {
                        breadcrumbItems.push({ label: topLevelGroup.category, action: null });
                    }
                    
                    // Add each level in hierarchy (except the current item)
                    for (let i = 0; i < hierarchyPath.length - 1; i++) {
                        const pathItem = hierarchyPath[i];
                        if (pathItem.type === 'skillgroup') {
                            breadcrumbItems.push({ 
                                label: `${pathItem.code} - ${pathItem.label}`, 
                                action: `selectItem('${pathItem.id}', 'skillgroup')` 
                            });
                        }
                    }
                }
                
                breadcrumbItems.push({ label: item.label, action: null }); // Current item
                
            } else if (item.type === 'skill') {
                // Individual skills breadcrumb (already working correctly)
                breadcrumbItems.push({ 
                    label: 'Skills', 
                    action: `switchMainTab('skills', document.querySelector('.nav-tab:nth-child(3)'))` 
                });
                
                // Trace complete hierarchy for individual skills
                const hierarchyPath = [];
                let currentId = item.id;
                let safetyCount = 0;
                
                while (currentId && safetyCount < 20) {
                    const currentItem = taxonomyData.skillsMaster[currentId];
                    if (currentItem) {
                        hierarchyPath.unshift(currentItem);
                    }
                    currentId = currentItem?.parentId;
                    safetyCount++;
                }
                
                // Add category and hierarchy path to breadcrumb
                if (hierarchyPath.length > 0) {
                    const topLevelGroup = hierarchyPath[0];
                    if (topLevelGroup.category) {
                        breadcrumbItems.push({ label: topLevelGroup.category, action: null });
                    }
                    
                    // Add each level in hierarchy (except the current item)
                    for (let i = 0; i < hierarchyPath.length - 1; i++) {
                        const pathItem = hierarchyPath[i];
                        if (pathItem.type === 'skillgroup') {
                            breadcrumbItems.push({ 
                                label: `${pathItem.code} - ${pathItem.label}`, 
                                action: `selectItem('${pathItem.id}', 'skillgroup')` 
                            });
                        } else if (pathItem.type === 'skill') {
                            breadcrumbItems.push({ 
                                label: pathItem.label, 
                                action: `selectItem('${pathItem.id}', 'skill')` 
                            });
                        }
                    }
                }
                
                breadcrumbItems.push({ label: item.label, action: null }); // Current item
            }
            
            if (breadcrumbItems.length === 0) return '';
            
            return `
                <div class="breadcrumb-nav" style="background: var(--tabiya-grey); padding: 16px 24px; margin-bottom: 24px; border-radius: 12px;">
                    <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; flex-wrap: wrap;">
                        ${breadcrumbItems.map((crumb, index) => {
                            const isLast = index === breadcrumbItems.length - 1;
                            return `
                                <span style="display: flex; align-items: center; gap: 8px;">
                                    ${crumb.action && !isLast ? 
                                        `<a href="javascript:void(0)" onclick="${crumb.action}" style="color: var(--oxford-blue); text-decoration: none; font-weight: 500; padding: 4px 8px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='var(--tabiya-light-green)'" onmouseout="this.style.background='transparent'">${crumb.label}</a>` : 
                                        `<span style="color: ${isLast ? 'var(--text-primary)' : 'var(--text-secondary)'}; font-weight: ${isLast ? '600' : '400'}; padding: 4px 8px;">${crumb.label}</span>`
                                    }
                                    ${!isLast ? '<i class="fas fa-chevron-right" style="color: var(--text-muted); font-size: 12px;"></i>' : ''}
                                </span>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }


        // Function to render occupations for skills OR sub-groups for skill groups
        function renderSkillOccupations(skill) {
            if (skill.type === 'skillgroup') {
                // For skill groups, show sub-groups and skills
                return renderSkillGroupChildren(skill);
            } else {
                // For individual skills, show related occupations
                const skillId = skill.id;
                
                const relatedOccupations = taxonomyData.occupationToSkills
                    .filter(rel => rel.skillId === skillId)
                    .map(rel => {
                        return taxonomyData.occupations.find(occ => occ.id === rel.occupationId);
                    })
                    .filter(Boolean)
                    .slice(0, 12);

                if (relatedOccupations.length === 0) {
                    return `
                        <div class="related-section">
                            <h4>Occupations requiring this skill</h4>
                            <p style="color: var(--text-muted); font-style: italic;">No occupations currently mapped to this skill.</p>
                        </div>
                    `;
                }

                const occupationLinks = relatedOccupations.map(occ => 
                    `<a href="javascript:void(0)" class="skill-link" onclick="selectItem('${occ.code}', 'occupation', event)">${occ.label}</a>`
                ).join(', ');

                return `
                    <div class="skills-section">
                        <h4><i class="fas fa-briefcase"></i>Occupations requiring this skill (${relatedOccupations.length})</h4>
                        <div class="skills-inline">
                            ${occupationLinks}
                        </div>
                    </div>
                `;
            }
        }

        // New function to render skill group children
        function renderSkillGroupChildren(skillGroup) {
            const childrenIds = skillGroup.childrenIds || [];
            const children = childrenIds.map(id => taxonomyData.skillsMaster[id]).filter(Boolean);
            
            // Separate skill groups and individual skills
            const childGroups = children.filter(child => child.type === 'skillgroup');
            const childSkills = children.filter(child => child.type === 'skill');
            
            let html = '';
            
            if (childGroups.length > 0) {
                html += `
                    <div class="related-section">
                        <h4>Sub-groups (${childGroups.length})</h4>
                        <div class="related-items">
                            ${childGroups.map(group => `
                                <div class="related-item" onclick="selectItem('${group.id}', 'skillgroup', event)">
                                    <div class="related-item-code">${group.code}</div>
                                    <div class="related-item-label">${group.label}</div>
                                    <div class="related-item-desc">${(group.description || '').substring(0, 120)}${group.description && group.description.length > 120 ? '...' : ''}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            if (childSkills.length > 0) {
                const skillLinks = childSkills.map(skill => 
                    `<a href="javascript:void(0)" class="skill-link" onclick="selectItem('${skill.id}', 'skill', event)">${skill.label}</a>`
                ).join(', ');
                
                html += `
                    <div class="skills-section">
                        <h4><i class="fas fa-tools"></i>Skills in this group (${childSkills.length})</h4>
                        <div class="skills-inline">
                            ${skillLinks}
                        </div>
                    </div>
                `;
            }
            
            if (!html) {
                return `
                    <div class="related-section">
                        <h4>Sub-groups and Skills</h4>
                        <p style="color: var(--text-muted); font-style: italic;">No sub-groups or skills found under this category.</p>
                    </div>
                `;
            }
            
            return html;
        }

        // Enhanced occupation skills rendering with Skills Master lookup
        function renderOccupationSkills(occupation) {
            // Use ID for relations lookup, not code
            const occupationId = taxonomyData.occupationCodeToId[occupation.code] || occupation.id;
            
            const occupationSkills = taxonomyData.occupationToSkills.filter(rel => 
                rel.occupationId === occupationId
            );

            if (occupationSkills.length === 0) {
                return `
                    <div class="skills-section">
                        <h4><i class="fas fa-tools"></i>Required Skills</h4>
                        <p style="color: var(--text-muted); font-style: italic;">No specific skills mapped for this occupation yet.</p>
                    </div>
                `;
            }

            // Get skill details using Skills Master
            const skillsWithDetails = occupationSkills.map(rel => {
                // Use Skills Master for skill lookup
                const skill = taxonomyData.skillsMaster[rel.skillId];
                return skill ? { ...skill, relation: rel } : null;
            }).filter(Boolean);

            // Group by relation type
            const skillsByRelation = {};
            skillsWithDetails.forEach(skill => {
                const relationType = skill.relation.relationType || 'related';
                if (!skillsByRelation[relationType]) {
                    skillsByRelation[relationType] = [];
                }
                skillsByRelation[relationType].push(skill);
            });

            let skillsHtml = '';
            
            // Define order for relation types
            const relationOrder = ['essential', 'optional', 'related', 'knowledge', 'skills'];
            
            // Process each relation type in order
            relationOrder.forEach(relationType => {
                if (skillsByRelation[relationType] && skillsByRelation[relationType].length > 0) {
                    const skills = skillsByRelation[relationType];
                    const relationLabel = formatRelationType(relationType);
                    
                    // Use skill ID for navigation and show proper labels
                    const skillLinks = skills.map(skill => 
                        `<a href="javascript:void(0)" class="skill-link" onclick="selectItem('${skill.id}', '${skill.type}', event)">${skill.label}</a>`
                    ).join(', ');
                    
                    skillsHtml += `
                        <div style="margin-bottom: 20px;">
                            <h5 style="color: var(--oxford-blue); margin-bottom: 12px; font-size: 16px; font-weight: 600;">
                                ${relationLabel} (${skills.length})
                            </h5>
                            <div class="skills-inline">
                                ${skillLinks}
                            </div>
                        </div>
                    `;
                }
            });
            
            // Process any remaining relation types not in the predefined order
            Object.keys(skillsByRelation).forEach(relationType => {
                if (!relationOrder.includes(relationType)) {
                    const skills = skillsByRelation[relationType];
                    const relationLabel = formatRelationType(relationType);
                    
                    const skillLinks = skills.map(skill => 
                        `<a href="javascript:void(0)" class="skill-link" onclick="selectItem('${skill.id}', '${skill.type}', event)">${skill.label}</a>`
                    ).join(', ');
                    
                    skillsHtml += `
                        <div style="margin-bottom: 20px;">
                            <h5 style="color: var(--oxford-blue); margin-bottom: 12px; font-size: 16px; font-weight: 600;">
                                ${relationLabel} (${skills.length})
                            </h5>
                            <div class="skills-inline">
                                ${skillLinks}
                            </div>
                        </div>
                    `;
                }
            });

            return `
                <div class="skills-section">
                    <h4><i class="fas fa-tools"></i>Required Skills (${skillsWithDetails.length})</h4>
                    ${skillsHtml}
                </div>
            `;
        }

        function formatRelationType(relationType) {
            const typeMap = {
                'essential': 'Essential Skills',
                'optional': 'Optional Skills',
                'related': 'Related Skills',
                'knowledge': 'Knowledge Requirements',
                'skills': 'Technical Skills'
            };
            return typeMap[relationType] || relationType.charAt(0).toUpperCase() + relationType.slice(1);
        }

        function renderRelatedItems(item) {
            if (item.level) { // It's a group
                const childOccupations = taxonomyData.occupations.filter(o => o.groupCode === item.code);
                const childGroups = taxonomyData.groups.filter(g => g.parent === item.code);
                
                let html = '';
                
                if (childGroups.length > 0) {
                    html += `
                        <div class="related-section">
                            <h4>Sub-groups</h4>
                            <div class="related-items">
                                ${childGroups.map(group => `
                                    <div class="related-item" onclick="selectItem('${group.code}', 'group', event)">
                                        <div class="related-item-code">${group.code}</div>
                                        <div class="related-item-label">${group.label}</div>
                                        <div class="related-item-desc">${(group.description || '').substring(0, 120)}${group.description && group.description.length > 120 ? '...' : ''}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
                
                if (childOccupations.length > 0) {
                    html += `
                        <div class="related-section">
                            <h4>Occupations in this group</h4>
                            <div class="related-items">
                                ${childOccupations.map(occ => `
                                    <div class="related-item" onclick="selectItem('${occ.code}', 'occupation', event)">
                                        <div class="related-item-code">${occ.code}</div>
                                        <div class="related-item-label">${occ.label}</div>
                                        <div class="related-item-desc">${(occ.description || '').substring(0, 120)}${occ.description && occ.description.length > 120 ? '...' : ''}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
                
                return html;
            }
            return '';
        }

        // Fixed search functionality with proper main thread fallback
        async function performSearchOptimized() {
            const query = document.getElementById('searchBox').value.trim();
    
            if (query) {
                updateURL({ searchQuery: query, itemId: null });
            } else {
                updateURL({ searchQuery: null, itemId: null });
            }
            
            // Show loading state
            const container = document.getElementById('treeContainer');
            container.innerHTML = `
                <div class="loading" style="text-align: center; padding: 40px;">
                    <i class="fas fa-search fa-spin" style="font-size: 2rem; color: var(--oxford-blue); margin-bottom: 16px;"></i>
                    <div style="color: var(--text-muted);">Searching "${query}"...</div>
                </div>
            `;
            
            try {
                // Use main thread search (web worker fallback removed for now)
                const results = await searchMainThreadOptimized(query);
                await renderSearchResultsOptimized(results, query);
                updateSearchStats(results.length, getTabItemCount(), query);
                
            } catch (error) {
                console.error("Search error:", error);
                container.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-exclamation-triangle"></i>
                        <h3>Search Error</h3>
                        <p>An error occurred while searching: ${error.message}</p>
                        <button onclick="document.getElementById('searchBox').value = ''; performSearchOptimized();" class="btn-control" style="margin-top: 20px;">
                            <i class="fas fa-times"></i> Clear Search
                        </button>
                    </div>
                `;
            }
        }


        // Update original function to call optimized version
        function performSearch() {
            performSearchOptimized();
        }


        function getTabItemCount() {
            // Add safety checks for undefined data
            if (!taxonomyData || !taxonomyData.stats) {
                console.warn("⚠️ taxonomyData.stats not available yet");
                return 0;
            }
            
            if (currentMainTab === 'skills') {
                // Only count skill groups (not individual skills)
                return taxonomyData.stats.totalSkillGroups || 0;
            } else if (currentSubTab === 'seen-occupations') {
                return taxonomyData.stats.seenTotal || 0;
            } else if (currentSubTab === 'unseen-occupations') {
                return taxonomyData.stats.unseenTotal || 0;
            }
            return 0;
        }
        function renderSearchResults(results, query) {
            const container = document.getElementById('treeContainer');
            
            if (results.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-search"></i>
                        <h3>No results found</h3>
                        <p>No items match "${query}". Try different keywords or check your spelling.</p>
                    </div>
                `;
                return;
            }
            
            let html = `<h4 style="margin: 0 0 20px 0; color: var(--oxford-blue); font-size: 18px; font-weight: 700;">Search Results (${results.length})</h4>`;
            
            results.forEach(item => {
                let type = 'occupation';
                let code = item.code;
                
                if (item.level) {
                    type = 'group';
                } else if (item.skillType !== undefined || item.category !== undefined) {
                    type = item.category ? 'skillgroup' : 'skill';
                    code = item.id; // Skills use ID as identifier
                }
                
                html += `
                    <div class="tree-item">
                        <div class="tree-node" onclick="selectItem('${code}', '${type}', event)" data-code="${code}">
                            <div class="tree-toggle"></div>
                            ${item.code ? `<span class="tree-code">${item.code}</span>` : ''}
                            <span class="tree-label">${highlightMatch(item.label, query)}</span>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function highlightMatch(text, query) {
            const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function exportData() {
            let dataToExport = [];
            let filename = `tabiya-taxonomy-${currentLanguage}`;
            
            if (currentSubTab === 'seen-occupations') {
                dataToExport = [
                    ...taxonomyData.occupations.filter(item => item.type === 'seen'),
                    ...taxonomyData.groups.filter(item => item.type === 'seen')
                ];
                filename += '-seen-economy';
            } else if (currentSubTab === 'unseen-occupations') {
                dataToExport = [
                    ...taxonomyData.occupations.filter(item => item.type === 'unseen'),
                    ...taxonomyData.groups.filter(item => item.type === 'unseen')
                ];
                filename += '-unseen-economy';
            } else if (currentMainTab === 'skills') {
                dataToExport = [...taxonomyData.skills, ...taxonomyData.skillGroups];
                filename += '-skills';
            } else {
                dataToExport = [...taxonomyData.occupations, ...taxonomyData.groups];
                filename += '-complete';
            }
            
            const headers = ['Code', 'Label', 'Type', 'Level', 'Parent', 'Description'];
            const csvContent = [
                headers.join(','),
                ...dataToExport.map(item => [
                    `"${item.code || item.id || ''}"`,
                    `"${item.label}"`,
                    `"${getItemTypeLabel(item)}"`,
                    `"${item.level || ''}"`,
                    `"${item.groupCode || item.parent || ''}"`,
                    `"${(item.description || '').replace(/"/g, '""')}"`
                ].join(','))
            ].join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function getItemTypeLabel(item) {
            if (item.skillType !== undefined || item.category !== undefined) return 'Skill';
            if (item.level) return 'Occupation Group';
            return 'Occupation';
        }

        function updateSearchStats(found = null, total = null, query = '') {
            const statsEl = document.getElementById('searchStats');
            const currentQuery = document.getElementById('searchBox').value.trim();
            
            if (found !== null && total !== null && query) {
                if (found === 0) {
                    statsEl.textContent = `No results for "${query}"`;
                } else {
                    statsEl.textContent = `Found ${found} of ${total} items for "${query}"`;
                }
            } else {
                const totalItems = getTabItemCount();
                
                if (currentQuery) {
                    statsEl.textContent = `Searching "${currentQuery}" in ${totalItems} items...`;
                } else {
                    const tabName = getTabDisplayName();
                    statsEl.textContent = `${totalItems} items in ${tabName}`;
                }
            }
        }

        function getTabDisplayName() {
            if (currentMainTab === 'skills') return 'Skills';
            if (currentSubTab === 'seen-occupations') return 'Seen Economy';
            if (currentSubTab === 'unseen-occupations') return 'Unseen Economy';
            return 'Current Tab';
        }

        function updateTabBadges() {
            // Add safety checks for undefined data
            if (!taxonomyData || !taxonomyData.stats) {
                console.warn("⚠️ taxonomyData.stats not available for badge updates");
                return;
            }
            
            // Update the actual counts in tab badges
            const occupationsTab = document.querySelector('.nav-tab .tab-badge');
            const skillsTab = document.getElementById('skillsTabBadge');
            const seenSubTab = document.querySelector('.sub-nav-tab .tab-badge');
            const unseenSubTab = document.querySelector('.sub-nav-tab:nth-child(2) .tab-badge');
            
            if (occupationsTab && taxonomyData.stats) {
                occupationsTab.textContent = (taxonomyData.stats.totalOccupations + taxonomyData.stats.totalGroups).toLocaleString();
            }
            
            if (skillsTab && taxonomyData.stats) {
                // Only show skill groups count (not individual skills)
                skillsTab.textContent = taxonomyData.stats.totalSkillGroups.toLocaleString();
            }
            
            if (seenSubTab && taxonomyData.stats) {
                seenSubTab.textContent = taxonomyData.stats.seenTotal.toLocaleString();
            }
            
            if (unseenSubTab && taxonomyData.stats) {
                unseenSubTab.textContent = taxonomyData.stats.unseenTotal.toLocaleString();
            }
        }
        function debounce(func, wait) {
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(searchTimeout);
                    func(...args);
                };
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(later, wait);
            };
        }

        // Browser navigation handler - handles back/forward buttons
        window.addEventListener('popstate', (event) => {
            console.log('🔙 Browser navigation detected');
            const state = event.state || parseURL(window.location.pathname, window.location.search);
            
            // Don't create new history entry when navigating back/forward
            urlState = state;
            
            // Update app to match URL state
            loadAppStateFromURL(state, true);
        });

        async function loadAppStateFromURL(state, isNavigating = false) {
            console.log('🔄 Loading app state from URL:', state);
            
            try {
                // Update language if different
                if (state.lang !== currentLanguage) {
                    console.log(`🌍 URL language change: ${currentLanguage} → ${state.lang}`);
                    currentLanguage = state.lang;
                    
                    // Update language buttons without triggering URL update
                    document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
                    document.getElementById(`lang-${state.lang}`).classList.add('active');
                    
                    updateLocalizationVisibility();
                }
                
                // Update localization if different  
                const newLoc = state.localization === 'base' ? null : state.localization;
                if (newLoc !== currentLocalization) {
                    console.log(`🏠 URL localization change: ${currentLocalization} → ${newLoc}`);
                    currentLocalization = newLoc;
                    
                    // Update localization buttons without triggering URL update
                    document.querySelectorAll('.loc-btn').forEach(btn => btn.classList.remove('active'));
                    if (newLoc) {
                        document.getElementById(`loc-${newLoc}`).classList.add('active');
                    } else {
                        document.getElementById('loc-base').classList.add('active');
                    }
                }
                
                // Load taxonomy data if language/localization changed
                if (state.lang !== currentLanguage || newLoc !== currentLocalization) {
                    await loadTaxonomyData();
                }
                
                // Update taxonomy tab if different
                if (state.taxonomy !== currentMainTab) {
                    console.log(`📂 URL tab change: ${currentMainTab} → ${state.taxonomy}`);
                    currentMainTab = state.taxonomy;
                    
                    // Update tab UI without triggering URL update
                    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                    if (state.taxonomy === 'occupations') {
                        document.querySelector('.nav-tab:nth-child(2)').classList.add('active');
                        document.getElementById('occupations-subtabs').classList.add('active');
                        showExplorerPanel();
                    } else if (state.taxonomy === 'skills') {
                        document.querySelector('.nav-tab:nth-child(3)').classList.add('active');
                        showExplorerPanel();
                    } else if (state.taxonomy === 'about') {
                        document.querySelector('.nav-tab:nth-child(1)').classList.add('active');
                        showAboutPanel();
                    }
                }
                
                // Render appropriate tree
                if (state.taxonomy === 'skills') {
                    await renderSkillsTreeOptimized();
                } else if (state.taxonomy === 'occupations') {
                    await renderTaxonomyTreeOptimized();
                }
                
                // Handle item selection or search
                if (state.itemId) {
                    console.log(`🎯 URL item selection: ${state.itemId}`);
                    selectItemById(state.itemId);
                } else if (state.searchQuery) {
                    console.log(`🔍 URL search query: ${state.searchQuery}`);
                    document.getElementById('searchBox').value = state.searchQuery;
                    performSearch();
                } else if (state.taxonomy === 'skills') {
                    showSkillsOverview();
                } else if (state.taxonomy === 'occupations') {
                    showOccupationsOverview();
                }
                
            } catch (error) {
                console.error('❌ Error loading app state from URL:', error);
            }
        }

        function initializeFromURL() {
            console.log('🚀 Initializing app from URL:', window.location.pathname);
            
            const currentState = parseURL(window.location.pathname, window.location.search);
            urlState = currentState;
            
            console.log('🔧 Parsed URL state:', currentState);
            
            // Set global app state from URL
            currentLanguage = currentState.lang;
            currentLocalization = currentState.localization === 'base' ? null : currentState.localization;
            
            // Update UI to match URL - language buttons
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`lang-${currentState.lang}`).classList.add('active');
            
            // Update UI to match URL - localization buttons
            if (currentState.localization !== 'base') {
                document.querySelectorAll('.loc-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`loc-${currentState.localization}`).classList.add('active');
            }
            
            // Show/hide localization selector based on language
            updateLocalizationVisibility();
            
            // Set taxonomy tab
            if (currentState.taxonomy !== 'about') {
                currentMainTab = currentState.taxonomy;
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                
                if (currentState.taxonomy === 'occupations') {
                    document.querySelector('.nav-tab:nth-child(2)').classList.add('active');
                    document.getElementById('occupations-subtabs').classList.add('active');
                } else if (currentState.taxonomy === 'skills') {
                    document.querySelector('.nav-tab:nth-child(3)').classList.add('active');
                }
            }
            
            // Load translations and data, then handle item selection
            Promise.resolve().then(() => {
                // Load data first
                return loadTaxonomyData();
            }).then(() => {
                // Once data is loaded, handle URL-specific actions
                if (currentState.itemId) {
                    console.log('🎯 Initial item selection from URL:', currentState.itemId);
                    selectItemById(currentState.itemId);
                } else if (currentState.searchQuery) {
                    console.log('🔍 Initial search from URL:', currentState.searchQuery);
                    document.getElementById('searchBox').value = currentState.searchQuery;
                    performSearch();
                } else {
                    // Show appropriate default view
                    if (currentState.taxonomy === 'skills') {
                        renderSkillsTreeOptimized().then(() => showSkillsOverview());
                    } else if (currentState.taxonomy === 'occupations') {
                        renderTaxonomyTreeOptimized().then(() => showOccupationsOverview());
                    } else {
                        showAboutPanel();
                    }
                }
            }).catch(error => {
                console.error('❌ Error initializing from URL:', error);
                // Fallback to default state
                showAboutPanel();
            });
        }

        // Make enhanced test function available globally
        window.taxonomyData = taxonomyData;
        window.selectItem = selectItem;
        

        // Performance helper functions
        async function flattenTreeDataForVirtualScrolling(groups) {
            const flattened = [];
            
            groups.sort((a, b) => {
                const aCode = a.code.toString();
                const bCode = b.code.toString();
                
                if (aCode === '0') return -1;
                if (bCode === '0') return 1;
                
                if (aCode.length === 1 && bCode.length === 1) {
                    return parseInt(aCode) - parseInt(bCode);
                }
                
                if (aCode.length !== bCode.length) {
                    return aCode.length - bCode.length;
                }
                
                return aCode.localeCompare(bCode, undefined, { numeric: true });
            });
            
            await performanceManager.processInChunks(groups, (group) => {
                const flatGroup = {
                    ...group,
                    level: 0,
                    hasChildren: hasChildGroups(group.code, group.type) || hasChildOccupations(group.code),
                    isExpanded: false,
                    type: 'group'
                };
                flattened.push(flatGroup);
                return flatGroup;
            }, { chunkSize: 50 });
            
            return flattened;
        }

        async function renderTreeTraditional(container, groups) {
            let html = '';
            
            await performanceManager.renderInChunks(
                { innerHTML: '' },
                groups,
                (group) => {
                    const hasChildren = hasChildGroups(group.code, group.type) || hasChildOccupations(group.code);
                    
                    return `
                        <div class="tree-item">
                            <div class="tree-node has-children" onclick="selectItem('${group.code}', 'group', event)" data-code="${group.code}">
                                <div class="tree-toggle" onclick="toggleGroupNode('${group.code}', event)">
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <span class="tree-code">${group.code}</span>
                                <span class="tree-label">${group.label}</span>
                            </div>
                            <div class="tree-children collapsed" id="children-${group.code}">
                                <!-- Children loaded on demand -->
                            </div>
                        </div>
                    `;
                },
                { chunkSize: 20 }
            );
            
            html = container.innerHTML;
            
            if (!html) {
                html = '<div class="empty-state"><i class="fas fa-search"></i><h3>No items found</h3><p>Try adjusting your search criteria.</p></div>';
            }
            
            container.innerHTML = html;
        }

        async function renderSkillCategoryContentOptimized(groups, category) {
            let html = '';
            
            // Filter to only show TOP-LEVEL groups in this category
            const topLevelGroups = groups.filter(group => {
                if (!group.parentId) return true;
                
                const parent = taxonomyData.skillsMaster[group.parentId];
                return !parent || parent.category !== category;
            });
            
            topLevelGroups.sort((a, b) => {
                return a.code.localeCompare(b.code, undefined, { numeric: true });
            });
            
            topLevelGroups.forEach(group => {
                const hasChildren = group.childrenIds && group.childrenIds.length > 0;
                
                html += `
                    <div class="tree-item">
                        <div class="tree-node ${hasChildren ? 'has-children' : ''}" 
                            onclick="handleTreeNodeClick('${group.id}', 'skillgroup', ${hasChildren}, event)" 
                            data-code="${group.id}"
                            style="font-family: var(--font-family-sans) !important; text-transform: none !important;">
                            ${hasChildren ? 
                                `<div class="tree-toggle"><i class="fas fa-chevron-right"></i></div>` : 
                                '<div class="tree-toggle"></div>'
                            }
                            <span class="tree-code" style="font-family: var(--font-family-sans) !important; text-transform: none !important;">${group.code}</span>
                            <span class="tree-label" style="font-family: var(--font-family-sans) !important; text-transform: none !important;">${group.label}</span>
                        </div>
                        ${hasChildren ? `<div class="tree-children collapsed" id="children-${group.id}"></div>` : ''}
                    </div>
                `;
            });
            
            setTimeout(applyFontFixes, 50);
            return html;
        }


        function renderSkillGroupWithChildrenOptimized(groupId) {
            const group = taxonomyData.skillsMaster?.[groupId];
            if (!group || group.type !== 'skillgroup') return '';
            
            return `
                <div class="tree-item">
                    <div class="tree-node" onclick="selectItem('${group.id}', 'skillgroup', event)" data-code="${group.id}">
                        <div class="tree-toggle"></div>
                        <span class="tree-code">${group.code}</span>
                        <span class="tree-label">${group.label}</span>
                    </div>
                </div>
            `;
        }

        async function searchMainThreadOptimized(query) {
            const queryLower = query.toLowerCase().trim();
            let searchItems = [];
            
            if (currentMainTab === 'skills') {
                searchItems = [...taxonomyData.skills, ...taxonomyData.skillGroups];
            } else if (currentSubTab === 'seen-occupations') {
                searchItems = [
                    ...taxonomyData.occupations.filter(item => item.type === 'seen'),
                    ...taxonomyData.groups.filter(item => item.type === 'seen')
                ];
            } else if (currentSubTab === 'unseen-occupations') {
                searchItems = [
                    ...taxonomyData.occupations.filter(item => item.type === 'unseen'),
                    ...taxonomyData.groups.filter(item => item.type === 'unseen')
                ];
            }
            
            const results = [];
            await performanceManager.processInChunks(searchItems, (item) => {
                const score = calculateSearchScore(item, queryLower);
                if (score > 0) {
                    return { item, score };
                }
                return null;
            }, { 
                chunkSize: 100,
                progressCallback: (progress) => {
                    const container = document.getElementById('treeContainer');
                    const loadingDiv = container.querySelector('.loading div:last-child');
                    if (loadingDiv) {
                        loadingDiv.textContent = `Searching "${query}" (${progress.processed}/${progress.total})...`;
                    }
                }
            }).then(chunkedResults => {
                chunkedResults.forEach(result => {
                    if (result) results.push(result);
                });
            });
            
            results.sort((a, b) => b.score - a.score);
            return results.slice(0, 100).map(r => r.item);
        }

        async function renderSearchResultsOptimized(results, query) {
            const container = document.getElementById('treeContainer');
            
            if (results.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-search"></i>
                        <h3>No results found</h3>
                        <p>No items match "${query}". Try different keywords or check your spelling.</p>
                    </div>
                `;
                return;
            }
            
            if (results.length > 50) {
                const searchScroller = new SearchVirtualScroller(container, {
                    itemHeight: 52,
                    renderItem: (item, index, isSelected) => renderSearchItemOptimized(item, index, isSelected, query)
                });
                searchScroller.setSearchResults(results, query);
                virtualScrollers.set('search', searchScroller);
            } else {
                let html = `<h4 style="margin: 0 0 20px 0; color: var(--oxford-blue); font-size: 18px; font-weight: 700;">Search Results (${results.length})</h4>`;
                
                await performanceManager.renderInChunks(
                    { innerHTML: '' },
                    results,
                    (item, index) => renderSearchItemOptimized(item, index, false, query),
                    { chunkSize: 25 }
                );
                
                container.innerHTML = html + container.innerHTML;
            }
        }

        function renderSearchItemOptimized(item, index, isSelected, query) {
            let type = 'occupation';
            let code = item.code;
            
            if (item.level) {
                type = 'group';
            } else if (item.skillType !== undefined || item.category !== undefined) {
                type = item.category ? 'skillgroup' : 'skill';
                code = item.id;
            }
            
            const selectedClass = isSelected ? 'selected' : '';
            const highlightedLabel = highlightMatchOptimized(item.label, query);
            
            return `
                <div class="tree-item">
                    <div class="tree-node ${selectedClass}" onclick="selectItem('${code}', '${type}', event)" data-code="${code}">
                        <div class="tree-toggle"></div>
                        ${item.code ? `<span class="tree-code">${item.code}</span>` : ''}
                        <span class="tree-label">${highlightedLabel}</span>
                    </div>
                </div>
            `;
        }

        // Enhanced highlighting that includes alternative labels
        function highlightMatchOptimized(text, query) {
            const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        // New function to render search item with alternative labels context
        function renderSearchItemOptimized(item, index, isSelected, query) {
            let type = 'occupation';
            let code = item.code;
            
            if (item.level) {
                type = 'group';
            } else if (item.skillType !== undefined || item.category !== undefined) {
                type = item.category ? 'skillgroup' : 'skill';
                code = item.id;
            }
            
            const selectedClass = isSelected ? 'selected' : '';
            const highlightedLabel = highlightMatchOptimized(item.label, query);
            
            // ENHANCEMENT #2a: Check if match was found in alternative labels
            let altLabelMatch = '';
            if (item.altLabels && item.altLabels.toLowerCase().includes(query.toLowerCase())) {
                const altLabelsArray = item.altLabels.split(/[,\n]/).map(label => label.trim());
                const matchingAltLabels = altLabelsArray.filter(altLabel => 
                    altLabel.toLowerCase().includes(query.toLowerCase())
                );
                
                if (matchingAltLabels.length > 0) {
                    const highlightedAltLabels = matchingAltLabels
                        .slice(0, 3) // Show max 3 matching alt labels
                        .map(altLabel => highlightMatchOptimized(altLabel, query))
                        .join(', ');
                    
                    altLabelMatch = `
                        <div style="font-size: 12px; color: var(--text-muted); font-style: italic; margin-top: 4px;">
                            Also known as: ${highlightedAltLabels}${matchingAltLabels.length > 3 ? '...' : ''}
                        </div>
                    `;
                }
            }
            
            return `
                <div class="tree-item">
                    <div class="tree-node ${selectedClass}" onclick="selectItem('${code}', '${type}', event)" data-code="${code}">
                        <div class="tree-toggle"></div>
                        ${item.code ? `<span class="tree-code">${item.code}</span>` : ''}
                        <div style="flex: 1;">
                            <span class="tree-label">${highlightedLabel}</span>
                            ${altLabelMatch}
                        </div>
                    </div>
                </div>
            `;
        }

        

        function toggleVirtualNode(nodeId, event) {
            if (event) event.stopPropagation();
            
            const treeScroller = virtualScrollers.get('tree');
            if (treeScroller) {
                treeScroller.toggleNode(nodeId);
            } else {
                toggleNodeGeneric(nodeId, event);
            }
        }

        // Data processing helper functions
        function processOccupationRow(row) {
            if (!row.CODE || !row.PREFERREDLABEL) return null;
            
            const code = row.CODE.toString().trim();
            const isUnseen = code.startsWith('I');
            
            return {
                id: row.ID,
                code: code,
                label: row.PREFERREDLABEL.trim(),
                description: row.DESCRIPTION ? row.DESCRIPTION.substring(0, 300).trim() : '',
                altLabels: row.ALTLABELS ? row.ALTLABELS.trim() : '',
                type: isUnseen ? 'unseen' : 'seen',
                groupCode: row.OCCUPATIONGROUPCODE ? row.OCCUPATIONGROUPCODE.toString().trim() : '',
                occupationType: row.OCCUPATIONTYPE || '',
                ISLOCALIZED: row.ISLOCALIZED || false
            };
        }

        function processGroupRow(row) {
            if (!row.CODE || !row.PREFERREDLABEL) return null;
            
            const code = row.CODE.toString().trim();
            const isUnseen = code.startsWith('I');
            
            let level = 1;
            if (isUnseen) {
                if (code.includes('_')) {
                    const parts = code.split('_');
                    level = parts.length + 1;
                } else if (code.length > 2) {
                    level = 2;
                }
            } else {
                const cleanCode = code.replace(/^0+/, '');
                level = Math.max(1, cleanCode.length);
            }
            
            return {
                id: row.ID,
                code: code,
                label: row.PREFERREDLABEL.trim(),
                description: row.DESCRIPTION ? row.DESCRIPTION.substring(0, 400).trim() : '',
                altLabels: row.ALTLABELS ? row.ALTLABELS.trim() : '',
                type: isUnseen ? 'unseen' : 'seen',
                level: level,
                groupType: row.GROUPTYPE || '',
                ISLOCALIZED: row.ISLOCALIZED || false
            };
        }

        function processSkillRow(row) {
            if (!row.ID) return null;
            
            return {
                id: row.ID,
                label: row.PREFERREDLABEL?.trim() || 'Unknown Skill',
                description: row.DESCRIPTION?.substring(0, 300).trim() || '',
                altLabels: row.ALTLABELS?.trim() || '',
                skillType: row.SKILLTYPE || 'General',
                reuseLevel: row.REUSELEVEL || '',
                ISLOCALIZED: row.ISLOCALIZED || false
            };
        }

        function processSkillGroupRow(row) {
            if (!row.ID) return null;
            
            let code = row.CODE?.toString().trim() || row.ID;
            let category = 'Other';
            
            if (code.startsWith('S')) {
                category = 'Skills and competencies';
            } else if (code.startsWith('L')) {
                category = 'Language';
            } else if (code.startsWith('T')) {
                category = 'Transversal skills';
            } else if (row.ORIGINURI?.includes('isced-f')) {
                category = 'Knowledge';
                const match = row.ORIGINURI.match(/isced-f\/(\d+)/);
                if (match) {
                    code = match[1];
                }
            }
            
            return {
                id: row.ID,
                code: code,
                label: row.PREFERREDLABEL?.trim() || 'Unknown Group',
                description: row.DESCRIPTION?.substring(0, 300).trim() || '',
                altLabels: row.ALTLABELS?.trim() || '',
                category: category,
                ISLOCALIZED: row.ISLOCALIZED || false
            };
        }

        function processHierarchyRow(row) {
            if (!row.PARENTID || !row.CHILDID) return null;
            return {
                parentId: row.PARENTID,
                childId: row.CHILDID
            };
        }

        function processSkillHierarchyRow(row) {
            if (!row.PARENTID || !row.CHILDID) return null;
            return {
                parentId: row.PARENTID,
                childId: row.CHILDID
            };
        }

        function processOccupationToSkillRow(row) {
            const hasOccId = row.OCCUPATIONID && row.OCCUPATIONID.toString().trim();
            const hasSkillId = row.SKILLID && row.SKILLID.toString().trim();
            
            if (!hasOccId || !hasSkillId) return null;
            
            return {
                occupationId: row.OCCUPATIONID.toString().trim(),
                skillId: row.SKILLID.toString().trim(),
                relationType: row.RELATIONTYPE || 'related',
                signallingValue: row.SIGNALLINGVALUE || 0,
                signallingValueLabel: row.SIGNALLINGVALUELABEL || ''
            };
        }

        async function buildSkillsMasterOptimized(skillHierarchy, skills, skillGroups) {
            
            const skillsMaster = new Map();
            const skillHierarchyMap = new Map();
            const skillParentMap = new Map();
            const skillDataById = new Map();
            const skillGroupDataById = new Map();
            
            // Build hierarchy maps
            skillHierarchy.forEach(rel => {
                const parentId = rel.parentId;
                const childId = rel.childId;
                
                if (!skillHierarchyMap.has(parentId)) {
                    skillHierarchyMap.set(parentId, []);
                }
                skillHierarchyMap.get(parentId).push(childId);
                skillParentMap.set(childId, parentId);
            });
            
            // Index data
            skills.forEach(skill => {
                if (skill.id) skillDataById.set(skill.id, skill);
            });
            
            skillGroups.forEach(group => {
                if (group.id) skillGroupDataById.set(group.id, group);
            });
            
            // Process all child IDs in chunks
            const allChildIds = Array.from(skillParentMap.keys());
            
            await performanceManager.processInChunks(allChildIds, (childId) => {
                const enrichedItem = createEnrichedSkillItemOptimized(
                    childId,
                    skillParentMap,
                    skillHierarchyMap,
                    skillDataById,
                    skillGroupDataById
                );
                
                if (enrichedItem) {
                    skillsMaster.set(childId, enrichedItem);
                }
                return enrichedItem;
            }, { chunkSize: 1000 });
            
            return Object.fromEntries(skillsMaster);
        }

        function createEnrichedSkillItemOptimized(childId, skillParentMap, skillHierarchyMap, skillDataById, skillGroupDataById) {
            const parentId = skillParentMap.get(childId);
            const childrenIds = skillHierarchyMap.get(childId) || [];
            
            let enrichedItem = {
                id: childId,
                parentId: parentId,
                childrenIds: childrenIds
            };
            
            const skillData = skillDataById.get(childId);
            const skillGroupData = skillGroupDataById.get(childId);
            
            if (skillData) {
                Object.assign(enrichedItem, {
                    type: 'skill',
                    label: skillData.label,
                    description: skillData.description,
                    altLabels: skillData.altLabels,
                    skillType: skillData.skillType,
                    reuseLevel: skillData.reuseLevel,
                    isClickable: true,
                    isSearchable: false,
                    ISLOCALIZED: skillData.ISLOCALIZED
                });
            } else if (skillGroupData) {
                Object.assign(enrichedItem, {
                    type: 'skillgroup',
                    code: skillGroupData.code,
                    label: skillGroupData.label,
                    description: skillGroupData.description,
                    altLabels: skillGroupData.altLabels,
                    category: skillGroupData.category,
                    isClickable: true,
                    isSearchable: true,
                    ISLOCALIZED: skillGroupData.ISLOCALIZED
                });
            } else {
                Object.assign(enrichedItem, {
                    type: 'unknown',
                    label: `Unknown Item (${childId})`,
                    isClickable: false,
                    isSearchable: false
                });
            }
            
            return enrichedItem;
        }

        function calculateStatsOptimized(processedData) {
            const stats = {
                totalOccupations: processedData.occupations?.length || 0,
                totalGroups: processedData.groups?.length || 0,
                totalSkills: processedData.skills?.length || 0,
                totalSkillGroups: processedData.skillGroups?.length || 0,
                totalItems: 0,
                unseenOccupations: 0,
                unseenGroups: 0,
                unseenTotal: 0,
                seenOccupations: 0,
                seenGroups: 0,
                seenTotal: 0,
                occupationSkillRelations: processedData.occupationToSkills?.length || 0
            };
            
            if (processedData.occupations) {
                processedData.occupations.forEach(occ => {
                    if (occ.type === 'unseen') stats.unseenOccupations++;
                    else stats.seenOccupations++;
                });
            }
            
            if (processedData.groups) {
                processedData.groups.forEach(group => {
                    if (group.type === 'unseen') stats.unseenGroups++;
                    else stats.seenGroups++;
                });
            }
            
            stats.unseenTotal = stats.unseenOccupations + stats.unseenGroups;
            stats.seenTotal = stats.seenOccupations + stats.seenGroups;
            stats.totalItems = stats.totalOccupations + stats.totalGroups + stats.totalSkills;
            
            return stats;
        }

        // Enhanced search scoring with alternative labels support
        function calculateSearchScore(item, query) {
            let score = 0;
            const queryLower = query.toLowerCase();
            
            // Exact matches get highest scores
            if (item.code && item.code.toLowerCase() === queryLower) score += 1000;
            if (item.label.toLowerCase() === queryLower) score += 800;
            
            // Start-with matches get high scores
            if (item.code && item.code.toLowerCase().startsWith(queryLower)) score += 500;
            if (item.label.toLowerCase().startsWith(queryLower)) score += 400;
            
            // Contains matches get medium scores
            if (item.label.toLowerCase().includes(queryLower)) score += 200;
            if (item.description && item.description.toLowerCase().includes(queryLower)) score += 100;
            
            // ENHANCEMENT #2a: Alternative Labels in Search
            if (item.altLabels && item.altLabels.trim()) {
                const altLabelsLower = item.altLabels.toLowerCase();
                
                // Check if any alternative label is an exact match
                const altLabelsArray = item.altLabels.split(/[,\n]/).map(label => label.trim().toLowerCase());
                const hasExactAltMatch = altLabelsArray.some(altLabel => altLabel === queryLower);
                if (hasExactAltMatch) score += 600; // High score for exact alt label match
                
                // Check if any alternative label starts with query
                const hasStartAltMatch = altLabelsArray.some(altLabel => altLabel.startsWith(queryLower));
                if (hasStartAltMatch) score += 300;
                
                // General contains match in alternative labels
                if (altLabelsLower.includes(queryLower)) score += 150;
            }
            
            // Boost score for localized items if viewing localized data
            if (currentLocalization && (item.isLocalized || item.ISLOCALIZED)) {
                score += 50;
            }
            
            return score;
        }

        function getPerformanceReport() {
            if (performanceManager) {
                const report = performanceManager.getPerformanceReport();
                return report;
            }
        }

        // Font corruption prevention
        function preventFontCorruption() {
            
            // Force UTF-8 encoding on all text nodes
            const walker = document.createTreeWalker(
                document.body,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let textNode;
            let processedNodes = 0;
            
            while (textNode = walker.nextNode()) {
                // Only process text nodes that might have corruption
                if (textNode.nodeValue && textNode.nodeValue.trim()) {
                    // Force proper text encoding
                    const parent = textNode.parentElement;
                    if (parent && (
                        parent.classList.contains('tree-label') ||
                        parent.classList.contains('tree-code') ||
                        parent.classList.contains('tree-node')
                    )) {
                        // Ensure parent has proper CSS properties
                        parent.style.fontFamily = 'var(--font-family-sans)';
                        parent.style.textTransform = 'none';
                        parent.style.unicodeBidi = 'normal';
                        parent.style.direction = 'ltr';
                        processedNodes++;
                    }
                }
            }
            
        }

        // Apply font corruption prevention after DOM updates
        function applyFontFixes() {
            // Apply immediately
            preventFontCorruption();
            
            // Apply after any dynamic content loads
            setTimeout(preventFontCorruption, 100);
            setTimeout(preventFontCorruption, 500);
        }


        //URL Parsing & Generation Functions
        function parseURL(pathname, search = '') {
            const segments = pathname.split('/').filter(Boolean);
            
            // Parse lang-localization from first segment
            const langLoc = segments[0] || 'en-base';
            const [lang, localization] = langLoc.split('-');
            
            // Parse search query if present
            const urlParams = new URLSearchParams(search);
            const searchQuery = urlParams.get('q');
            
            return {
                lang: lang || 'en',
                localization: localization || 'base',
                taxonomy: segments[1] || 'about',
                itemId: segments[2] || null,
                searchQuery: searchQuery
            };
        }

        function generateURL(state) {
            const langLoc = `${state.lang}-${state.localization}`;
            
            if (state.searchQuery) {
                return `/${langLoc}/search?q=${encodeURIComponent(state.searchQuery)}`;
            }
            
            if (state.itemId) {
                return `/${langLoc}/${state.taxonomy}/${state.itemId}`;
            }
            
            return `/${langLoc}/${state.taxonomy}`;
        }

        function updateURL(newState, replaceState = false) {
            Object.assign(urlState, newState);
            const url = generateURL(urlState);
            
            if (replaceState) {
                window.history.replaceState(urlState, '', url);
            } else {
                window.history.pushState(urlState, '', url);
            }
        }

        // Enhanced cleanup and error handling
        window.addEventListener('beforeunload', function() {
            if (dataWorker) {
                dataWorker.terminate();
            }
            
            virtualScrollers.forEach(scroller => {
                scroller.destroy();
            });
            virtualScrollers.clear();
            
            if (performanceManager) {
                performanceManager.cancel();
            }
        });

        // Make functions available globally for debugging
        window.getPerformanceReport = getPerformanceReport;
        window.performanceManager = () => performanceManager;
        window.virtualScrollers = virtualScrollers;

    </script>
</body>
</html>